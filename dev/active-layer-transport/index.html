<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Active Layer Transport · CarboKitten</title><meta name="title" content="Active Layer Transport · CarboKitten"/><meta property="og:title" content="Active Layer Transport · CarboKitten"/><meta property="twitter:title" content="Active Layer Transport · CarboKitten"/><meta name="description" content="Documentation for CarboKitten."/><meta property="og:description" content="Documentation for CarboKitten."/><meta property="twitter:description" content="Documentation for CarboKitten."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="CarboKitten logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CarboKitten</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../bosscher-1992/">Bosscher and Schlager 1992</a></li><li><a class="tocitem" href="../ca-with-production/">Model with CA and Production</a></li><li><a class="tocitem" href="../model-alcap/">ALCAPS</a></li><li><a class="tocitem" href="../models/without-ca/">Model without CA</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../first_tutorial/">Tutorial (Pluto notebook)</a></li><li><a class="tocitem" href="../cases/tabular-sea-level/">Tabular Sea Levels</a></li></ul></li><li><a class="tocitem" href="../architecture/">Architecture</a></li><li><span class="tocitem">Model Components</span><ul><li><a class="tocitem" href="../components/components/">Components</a></li><li><a class="tocitem" href="../components/tag/">Tags</a></li><li><a class="tocitem" href="../components/boxes/">Boxes</a></li><li><a class="tocitem" href="../components/time/">Time</a></li><li><a class="tocitem" href="../components/output/">Output</a></li><li><a class="tocitem" href="../components/facies/">Facies</a></li><li><a class="tocitem" href="../components/cellular-automata/">Cellular Automata</a></li><li><a class="tocitem" href="../components/waterdepth/">Water Depth</a></li><li><a class="tocitem" href="../components/production/">Production</a></li><li><a class="tocitem" href="../components/sediment_buffer/">Sediment Buffers</a></li><li class="is-active"><a class="tocitem" href>Active Layer Transport</a><ul class="internal"><li><a class="tocitem" href="#Test-1:-production-transport"><span>Test 1: production transport</span></a></li><li><a class="tocitem" href="#One-dimensional-tests"><span>One-dimensional tests</span></a></li><li><a class="tocitem" href="#Active-Layer-Component"><span>Active Layer Component</span></a></li><li><a class="tocitem" href="#Intertidal-zone"><span>Intertidal zone</span></a></li></ul></li><li><a class="tocitem" href="../onshore-transport/">Onshore Transport</a></li></ul></li><li><a class="tocitem" href="../visualization/">Visualizations</a></li><li><span class="tocitem">CarboCAT</span><ul><li><a class="tocitem" href="../carbocat/">Summary</a></li></ul></li><li><span class="tocitem">Denudation</span><ul><li><a class="tocitem" href="../denudation/denudation/">Denudation</a></li><li><a class="tocitem" href="../denudation/empirical/">Empirical Denudation</a></li><li><a class="tocitem" href="../denudation/chemical/">Chemical Dissolution</a></li><li><a class="tocitem" href="../denudation/physical_erosion/">Physical Erosion</a></li></ul></li><li><span class="tocitem">Input &amp; Output</span><ul><li><a class="tocitem" href="../input-methods/">Input Methods</a></li><li><a class="tocitem" href="../output/abstract/">Output</a></li><li><a class="tocitem" href="../output/h5writer/">HDF5 Output</a></li><li><a class="tocitem" href="../output/memory-writer/">Output to Memory</a></li><li><a class="tocitem" href="../data-export/">CSV Export</a></li></ul></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../unitful/">Unitful</a></li><li><a class="tocitem" href="../boxes/">Boxes</a></li><li><a class="tocitem" href="../stencils/">Stencils</a></li><li><a class="tocitem" href="../utility/">Utility</a></li><li><a class="tocitem" href="../finite-difference-transport/">Finite Difference</a></li></ul></li><li><a class="tocitem" href="../api/">API Documentation</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model Components</a></li><li class="is-active"><a href>Active Layer Transport</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Active Layer Transport</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MindTheGap-ERC/CarboKitten.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MindTheGap-ERC/CarboKitten.jl/blob/main/docs/transpiled/active-layer-transport.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Active-Layer-Transport"><a class="docs-heading-anchor" href="#Active-Layer-Transport">Active Layer Transport</a><a id="Active-Layer-Transport-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Layer-Transport" title="Permalink"></a></h1><p>The following is inspired on well-known <strong>active layer</strong> approaches in river bed sediment transport [<a href="../references/#Paola1992">4</a>] [<a href="../references/#James2010">5</a>] <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. All quantities with subscript <span>$f$</span> are facies dependent. Sediment is measured in meters of deposited material. <span>$P_f$</span> is the production of sediment per facies in <span>$m/s$</span>. Further unit calculations would be more readable if we consider the unit of sediment as separate, so for instance it doesn&#39;t cancel against <span>$m^2$</span> in the units of sediment flux. In the implementation, <span>$\nu$</span> has the units of <span>${\rm m}$</span> which is totaly weird. TBC</p><p>In a model without transport, we could write</p><p class="math-container">\[\sigma + \sum_f {{\partial \eta_f} \over {\partial t}} = \sum_f P_f,\]</p><p>where <span>$\sigma$</span> is the subsidence rate in <span>$m/s$</span>. We consider the mass balance for each facies separately.</p><p>We suppose that loose sediment, either fresh production or disintegrated older sediment, is being transported in a layer on top of the sea bed. The flux in this layer is assumed to be directly proportional to the local slope of the sea bed <span>$| \nabla_x \eta_* |$</span>, where <span>$\eta_* = \sum_f \eta_f$</span>, the sum over all facies contributions, including <span>$\eta_0$</span>, the initial bedrock eleveation.</p><p><img src="../fig/active-layer-export.svg" alt="Schematic of Active Layer approach"/></p><p>The active layer now contains a concentration <span>$C_f$</span> particles of different grain size (for each facies <span>$f$</span>). If needed, <span>$C_f = \alpha_f P_f$</span> where <span>$\alpha_f$</span> is some facies parameter determining the fraction of production that is available for transport. The sediment flux is given as,</p><p class="math-container">\[{\bf q_f} = -\nu_f C_f {\bf \nabla_x} \eta_*.\]</p><p>The following is the mass balance:</p><p class="math-container">\[\sigma + {{\partial \eta_*} \over {\partial t}} = -\sum_f {\bf \nabla_x} \cdot {\bf q_f} + \sum_f P_f,\]</p><p>In our modelling we keep track of individual contributions per facies over time <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><p>Combining these equations, and ignoring subsidence for the moment (which is a global effect and can&#39;t be expressed on a per-facies basis), we get a component-wise diffusion equation</p><p class="math-container">\[{{\partial \eta_f(x)}\over{\partial t}} = {\bf \nabla_x} \cdot \big[ \nu_f \alpha_f\ P_f(x)\ {\bf \nabla_x} \eta_{*}(x) \big] + P_f(x),\]</p><p>In our model we need to solve this equation one time-step each iteration. If we solve this using forward methods, we should be reminded of the CFL limit for diffusion equations (depending on the diffusion constants and grid size we shouldn&#39;t pick the time steps too large). Alternatively, for these two-dimensional situations, an implicit approach is feasible. Also we should take care that somehow <span>$\nabla(\nu\alpha P \nabla \eta) + P &gt; 0$</span>. The interpretation being that we can&#39;t transport more than we produce, even if there is capacity to do so.</p><p>To solve this equation, it is nicer to expand the transport-diffusion term using the product rule, in short notation:</p><p class="math-container">\[\partial_t \eta_f = \nu&#39; \nabla P_f(x) \cdot \nabla \eta(x) + \nu&#39; P_f(x) \nabla^2 \eta(x) + P_f(x),\]</p><p>where <span>$\nu&#39; = \nu_f \alpha_f$</span></p><p>So we have a advection component with velocity <span>$\nu&#39; \nabla P_f$</span> and a diffusion component with a coefficient <span>$\nu&#39; P_f$</span>.</p><p>As part of the production <span>$P_f$</span> we disintegrate older sediment at a fixed rate.</p><p><img src="../fig/active-layer-diagram.plain.svg" alt="Schema of active layer processes"/></p><h2 id="Test-1:-production-transport"><a class="docs-heading-anchor" href="#Test-1:-production-transport">Test 1: production transport</a><a id="Test-1:-production-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Test-1:-production-transport" title="Permalink"></a></h2><p>Suppose we have an incline in one direction, as per usual on a coastal slice. Production is happening in a circular patch in our box, with constant rate. In addition, we&#39;ll release the top 1m of sediment for further transport.</p><details><summary>Test model</summary><div class="noweb-label">file:<i>examples/transport/active-layer.jl</i></div><pre><code class="language- julia hljs">module ActiveLayer

using Unitful
using CarboKitten.Config: Box, axes
using CarboKitten.BoundaryTrait: Shelf
using CarboKitten.Utility: in_units_of
using CarboKitten.Transport.ActiveLayer: pde_stencil, Amount, Rate

&lt;&lt;example-active-layer&gt;&gt;

end</code></pre></details><p>Our input structure facilitates a single facies, specifying an initial bedrock elevation, sediment layer and a function for a location dependent constant production rate. The transport is parametrized by a disintegration rate and a diffusion coefficient.</p><div class="noweb-label">⪡example-active-layer⪢≣</div><pre><code class="language- julia hljs">@kwdef struct Input
    box
    Δt::typeof(1.0u&quot;Myr&quot;)
    t_end::typeof(1.0u&quot;Myr&quot;)
    initial_topography   # function (x::u&quot;m&quot;, y::u&quot;m&quot;) -&gt; u&quot;m&quot;
    initial_sediment    # function (x::u&quot;m&quot;, y::u&quot;m&quot;) -&gt; u&quot;m&quot;
    production          # function (x::u&quot;m&quot;, y::u&quot;m&quot;) -&gt; u&quot;m/s&quot;
    disintegration_rate::typeof(1.0u&quot;m/Myr&quot;)
    subsidence_rate::typeof(1.0u&quot;m/Myr&quot;)
    diffusion_coefficient::typeof(1.0u&quot;m/yr&quot;)
end</code></pre><h3 id="Production-patch"><a class="docs-heading-anchor" href="#Production-patch">Production patch</a><a id="Production-patch-1"></a><a class="docs-heading-anchor-permalink" href="#Production-patch" title="Permalink"></a></h3><p>Establish a grid of 100x50, 15km on each side, dropping from 0 to 50m depth. Keeping the disintegration rate to a similar value as the production rate seems a sensible choice.</p><div class="noweb-label">⪡example-active-layer⪢≣</div><pre><code class="language- julia hljs">production_patch(center, radius, rate) = function(x, y)
    (pcx, pcy) = center
    (x - pcx)^2 + (y - pcy)^2 &lt; radius^2 ?
        rate :
        0.0u&quot;m/Myr&quot;
end

const input = Input(
    box=Box{Shelf}(grid_size=(100, 50), phys_scale=150.0u&quot;m&quot;),
    Δt=0.001u&quot;Myr&quot;,
    t_end=1.0u&quot;Myr&quot;,

    initial_topography = (x, y) -&gt; -x / 300.0,
    initial_sediment = (x, y) -&gt; 0.0u&quot;m&quot;,

    production = production_patch(
        (5000.0u&quot;m&quot;, 3750.0u&quot;m&quot;),
        2.0u&quot;km&quot;,
        50.0u&quot;m/Myr&quot;),

    disintegration_rate = 50.0u&quot;m/Myr&quot;,
    subsidence_rate = 50.0u&quot;m/Myr&quot;,

    diffusion_coefficient = 10.0u&quot;m/yr&quot;
)</code></pre><p><img src="../fig/active-layer-production-patch.png" alt="Production patch on an inclining bedrock"/></p><details><summary>Plotting code</summary><div class="noweb-label">file:<i>examples/transport/active-layer-plot-production.jl</i></div><pre><code class="language- julia hljs">#| requires: examples/transport/active-layer.jl
#| creates: docs/src/_fig/active-layer-production-patch.png
#| collect: figures

include(&quot;active-layer.jl&quot;)
using Unitful
using CarboKitten.Config: axes
using CarboKitten.Utility: in_units_of
using CairoMakie
using .ActiveLayer: input

function main()
  (x, y) = axes(input.box)
  η = input.initial_topography.(x, y&#39;)
  p = input.production.(x, y&#39;)

  fig = Figure()
  ax = Axis3(fig[1,1], xlabel=&quot;x (km)&quot;, ylabel=&quot;y (km)&quot;, zlabel=&quot;η (m)&quot;, azimuth=5π/3)
  surface!(ax, x |&gt; in_units_of(u&quot;km&quot;), y |&gt; in_units_of(u&quot;km&quot;), η |&gt; in_units_of(u&quot;m&quot;), color = p |&gt; in_units_of(u&quot;m/Myr&quot;))
  save(&quot;docs/src/_fig/active-layer-production-patch.png&quot;, fig)
end

main()</code></pre></details><h3 id="Solving-the-PDE"><a class="docs-heading-anchor" href="#Solving-the-PDE">Solving the PDE</a><a id="Solving-the-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-PDE" title="Permalink"></a></h3><p>Just as a reminder:</p><p class="math-container">\[\partial_t \eta_f = \nu&#39; \nabla P_f(x) \cdot \nabla \eta(x) + \nu&#39; P_f(x) \nabla^2 \eta(x) + P_f(x)\]</p><p>Below is the kernel encoding a central differencing scheme i.e. <code>[-1, 0, 1]/(2Δx)</code> for first derivative and <code>[0 -1 0; -1 4 -1; 0 -1 0]/Δx^2</code> for the laplacian.</p><div class="noweb-label">file:<i>src/Transport/ActiveLayer.jl</i></div><pre><code class="language- julia hljs">module ActiveLayer

using Unitful
using StaticArrays
using ...BoundaryTrait
using ...Boxes: Box
using ...Stencil: stencil!

const Rate = typeof(1.0u&quot;m/Myr&quot;)
const Amount = typeof(1.0u&quot;m&quot;)

function pde_stencil(box::Box{BT}, Δt, ν, out, η, C) where {BT&lt;:Boundary{2}}
    Δx = box.phys_scale
    d = ν * Δt

    stencil!(BT, Size(3, 3), out, η, C) do η, C
        adv = d * ((η[3, 2] - η[1, 2]) * (C[3, 2] - C[1, 2]) +
                   (η[2, 3] - η[2, 1]) * (C[2, 3] - C[2, 1])) /
              (2Δx)^2

        dif = d * C[2, 2] * (η[3, 2] + η[2, 3] + η[1, 2] +
                             η[2, 1] - 4 * η[2, 2]) / (Δx)^2

        prd = C[2, 2]

        max(0.0u&quot;m&quot;, adv + dif + prd)
    end
end

end</code></pre><h3 id="Model-loop"><a class="docs-heading-anchor" href="#Model-loop">Model loop</a><a id="Model-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Model-loop" title="Permalink"></a></h3><p>Every iteration we determine the maximum disintegrated sediment. If the total amount of sediment is smaller than the maximum, then that amount is disintegrated instead. We compute the concentrations in the active layer in terms of amounts of sediment, so <span>$P \Delta t$</span>. Since <span>$P$</span> appears in every term of the PDE, we&#39;re free to do so.</p><div class="noweb-label">⪡example-active-layer⪢≣</div><pre><code class="language- julia hljs">mutable struct State
    time::typeof(1.0u&quot;Myr&quot;)
    sediment::Matrix{typeof(1.0u&quot;m&quot;)}
end

function initial_state(input)
    x, y = axes(input.box)
    State(0.0u&quot;Myr&quot;, input.initial_sediment.(x, y&#39;))
end

struct Frame
    t::typeof(1.0u&quot;Myr&quot;)
    δ::Matrix{Amount}
end

function propagator(input)
    δ = Matrix{Amount}(undef, input.box.grid_size...)
    x, y = axes(input.box)
    μ0 = input.initial_topography.(x, y&#39;)
    box = input.box
    Δt = input.Δt
    disintegration_rate = input.disintegration_rate
    production = input.production
    d = input.diffusion_coefficient

    function active_layer(state)
        max_amount = disintegration_rate * Δt
        amount = min.(max_amount, state.sediment)
        state.sediment .-= amount

        production.(x, y&#39;) * Δt .+ amount
    end

    function (state)
        p = active_layer(state)
        pde_stencil(box, Δt, d, δ, state.sediment .+ μ0, p)
        return Frame(state.time, δ)
    end
end

function run_model(input)
    state = initial_state(input)
    prop = propagator(input)

    Channel{State}() do ch
        while state.time &lt; input.t_end
            Δ = prop(state)
            state.sediment .+= Δ.δ
            state.time += input.Δt
            put!(ch, state)
        end
    end
end</code></pre><h3 id="Running-the-model"><a class="docs-heading-anchor" href="#Running-the-model">Running the model</a><a id="Running-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-model" title="Permalink"></a></h3><p>We run the model with 1000 time steps but only inspect one in every 100.</p><p><img src="../fig/active-layer-test.png" alt="Active layer test"/></p><details><summary>Plotting code</summary><div class="noweb-label">file:<i>examples/transport/active-layer-plot-result.jl</i></div><pre><code class="language- julia hljs">#| requires: examples/transport/active-layer.jl
#| creates: docs/src/_fig/active-layer-test.png
#| collect: figures

module ActiveLayerPlot

include(&quot;active-layer.jl&quot;)
using CairoMakie
using Unitful
using CarboKitten.Config: axes
using CarboKitten.Utility: in_units_of
using .ActiveLayer: input, run_model

function main()
  result = Iterators.map(deepcopy,
      Iterators.filter(x -&gt; mod(x[1], 100) == 0, enumerate(run_model(input)))) |&gt; collect

    (x, y) = axes(input.box)
    η = input.initial_topography.(x, y&#39;) .+ result[10][2].sediment .- input.subsidence_rate * result[10][2].time
    # p = input.production.(x, y&#39;)

    fig = Figure(size=(800, 1000))
    ax = Axis3(fig[1:2,1], xlabel=&quot;x (km)&quot;, ylabel=&quot;y (km)&quot;, zlabel=&quot;η (m)&quot;, azimuth=5π/3)
    surface!(ax, x |&gt; in_units_of(u&quot;km&quot;), y |&gt; in_units_of(u&quot;km&quot;), η |&gt; in_units_of(u&quot;m&quot;))

    ax2 = Axis(fig[3,1], xlabel=&quot;x (km)&quot;, ylabel=&quot;η (m)&quot;)

    for i in 1:10
        η = input.initial_topography.(x, y&#39;) .+ result[i][2].sediment .- input.subsidence_rate * result[i][2].time

        lines!(ax2, x |&gt; in_units_of(u&quot;km&quot;), η[:, 25] |&gt; in_units_of(u&quot;m&quot;))
    end

    save(&quot;docs/src/_fig/active-layer-test.png&quot;, fig)
end

end

ActiveLayerPlot.main()</code></pre></details><p>Note in the bottom figure, due to sedimentation not keeping up with subsidence, the lines go down in time. We see the sediment transport being favoured to downslope areas, which is what we want. This effect could be made more extreme by increasing the disintegration rate.</p><h2 id="One-dimensional-tests"><a class="docs-heading-anchor" href="#One-dimensional-tests">One-dimensional tests</a><a id="One-dimensional-tests-1"></a><a class="docs-heading-anchor-permalink" href="#One-dimensional-tests" title="Permalink"></a></h2><div class="noweb-label">file:<i>examples/transport/plot-1d-evolution.jl</i></div><pre><code class="language- julia hljs">&lt;&lt;plot-1d-evolution&gt;&gt;</code></pre><div class="noweb-label">⪡plot-1d-evolution⪢≣</div><pre><code class="language- julia hljs">using Printf: @sprintf
using Unitful: ustrip

function plot_1d_evolution!(ax::Axis, input, every=100)
	y_idx = 1
	(x, y) = box_axes(input.box)
	state = ALCAP.initial_state(input)

	plot_state() = begin
		t = state.step * input.time.Δt
		η = input.initial_topography.(x, y&#39;) .+ 
            state.sediment_height .-
            input.subsidence_rate * t
		lines!(ax, x |&gt; in_units_of(u&quot;km&quot;), η[:, y_idx] |&gt; in_units_of(u&quot;m&quot;),
               label=@sprintf(&quot;%.3f Myr&quot;, ustrip(t)))
	end

	plot_state()
	run_model(Model{ALCAP}, input, state) do i, _
		if mod(i, every) == 0
			plot_state()
		end
	end
end

function plot_1d_evolution(input, every=100)
	fig = Figure()
	ax = Axis(fig[1, 1], xlabel=&quot;x (km)&quot;, ylabel=&quot;η (m)&quot;)

    plot_1d_evolution!(ax, input, every)

	Legend(fig[1, 2], ax)

	fig
end</code></pre><div class="noweb-label">file:<i>src/Testing.jl</i></div><pre><code class="language- julia hljs">module Testing

using ..CarboKitten
using ..Models.ALCAP
using Unitful
using GeometryBasics

transport_test_input(;
	initial_topography = (x, y) -&gt; 0.0u&quot;m&quot;,
	initial_sediment = (x, y) -&gt; 0.0u&quot;m&quot;,
	disintegration_rate = 50.0u&quot;m/Myr&quot;,
	subsidence_rate = 0.0u&quot;m/Myr&quot;,
	diffusion_coefficient = 0.0u&quot;m/yr&quot;,
	wave_velocity = _ -&gt; (Vec2(0.0, 0.0)u&quot;m/yr&quot;, Vec2(0.0, 0.0)u&quot;1/yr&quot;),
    intertidal_zone = 0.0u&quot;m&quot;) =

	ALCAP.Input(
		box = CarboKitten.Box{Coast}(grid_size=(120, 1), phys_scale=125.0u&quot;m&quot;),
		time = TimeProperties(
			Δt = 0.001u&quot;Myr&quot;,
			steps = 1000),
		facies = [ALCAP.Facies(
			initial_sediment = initial_sediment,
			diffusion_coefficient = diffusion_coefficient,
			wave_velocity = wave_velocity,
			maximum_growth_rate = 0.0u&quot;m/Myr&quot;,
			extinction_coefficient = 0.8u&quot;m^-1&quot;,
			saturation_intensity = 60u&quot;W/m^2&quot;
		)],
		disintegration_rate = disintegration_rate,
		initial_topography = initial_topography,
		insolation = 400.0u&quot;W/m^2&quot;,
		sediment_buffer_size = 5,
		depositional_resolution = 1000.0u&quot;m&quot;,
		transport_solver = Val{:forward_euler},
        subsidence_rate = subsidence_rate,
        intertidal_zone = intertidal_zone)

end</code></pre><h3 id="Erosion"><a class="docs-heading-anchor" href="#Erosion">Erosion</a><a id="Erosion-1"></a><a class="docs-heading-anchor-permalink" href="#Erosion" title="Permalink"></a></h3><p>The erosion scenario tests that sharp sediment profiles erode under diffusive transport.</p><p><img src="../fig/1d-erosion.svg" alt="Erosion"/></p><div class="noweb-label">file:<i>examples/transport/1d-erosion.jl</i></div><pre><code class="language- julia hljs">#| creates: docs/src/_fig/1d-erosion.svg
#| collect: figures

module Script
    using CarboKitten
    using CarboKitten.Testing: transport_test_input
    using CairoMakie

    include(&quot;plot-1d-evolution.jl&quot;)

	function initial_sediment(x, y)
	  if x &lt; 5.0u&quot;km&quot;
	    return 30.0u&quot;m&quot;
	  end

	  if x &gt; 10.0u&quot;km&quot; &amp;&amp; x &lt; 11.0u&quot;km&quot;
	    return 20.0u&quot;m&quot;
	  end

	  return 5.0u&quot;m&quot;
	end

    function main()
        CairoMakie.activate!()
        input = transport_test_input(
            initial_topography = (x, y) -&gt; -30.0u&quot;m&quot;,
            initial_sediment = initial_sediment,
            diffusion_coefficient = 10.0u&quot;m/yr&quot;)

        fig = plot_1d_evolution(input, 250)
        save(&quot;docs/src/_fig/1d-erosion.svg&quot;, fig)
    end
end

Script.main()</code></pre><h3 id="Advection"><a class="docs-heading-anchor" href="#Advection">Advection</a><a id="Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Advection" title="Permalink"></a></h3><p>To test advective properties, we set disintegration rate to infinity, This way, surface gradients are zero and we get pure advection.</p><p><img src="../fig/1d-advection.svg" alt="advection"/></p><div class="noweb-label">file:<i>examples/transport/1d-advection.jl</i></div><pre><code class="language- julia hljs">#| creates: docs/src/_fig/1d-advection.svg
#| collect: figures

module Script
    using CarboKitten
    using CarboKitten.Testing: transport_test_input
    using CairoMakie

    include(&quot;plot-1d-evolution.jl&quot;)

    function gaussian_initial_sediment(x, y)
        exp(-(x-10u&quot;km&quot;)^2 / (2 * (0.5u&quot;km&quot;)^2)) * 30.0u&quot;m&quot;
    end

    v_const(v_max) = _ -&gt; (Vec2(v_max, 0.0u&quot;m/yr&quot;), Vec2(0.0u&quot;1/yr&quot;, 0.0u&quot;1/yr&quot;))

    function main()
        CairoMakie.activate!()
        input = transport_test_input(
            initial_topography = (x, y)  -&gt; -30.0u&quot;m&quot;,
            initial_sediment = gaussian_initial_sediment,
            disintegration_rate = 50000.0u&quot;m/Myr&quot;,
            wave_velocity = v_const(-5u&quot;km/Myr&quot;)
        )

        fig = plot_1d_evolution(input, 250)
        save(&quot;docs/src/_fig/1d-advection.svg&quot;, fig)
    end
end

Script.main()</code></pre><h3 id="Onshore-transport"><a class="docs-heading-anchor" href="#Onshore-transport">Onshore transport</a><a id="Onshore-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Onshore-transport" title="Permalink"></a></h3><p>This test shows the difference between having a velocity profile without and with shear.</p><p><img src="../fig/1d-onshore.svg" alt="onshore"/></p><div class="noweb-label">file:<i>examples/transport/1d-onshore.jl</i></div><pre><code class="language- julia hljs">#| creates: docs/src/_fig/1d-onshore.svg
#| collect: figures

module Script
    using CarboKitten
    using CarboKitten.Testing: transport_test_input
    using CairoMakie

    include(&quot;plot-1d-evolution.jl&quot;)

    v_prof(v_max, max_depth, w) = 
        let k = sqrt(0.5) / max_depth,
            A = 3.331 * v_max,
            α = tanh(k * w),
            β = exp(-k * w)
            (A * α * β, -A * k * β * (1 - α - α^2))
        end

    v_const(v_max) = _ -&gt; (Vec2(v_max, 0.0u&quot;m/yr&quot;), Vec2(0.0u&quot;1/yr&quot;, 0.0u&quot;1/yr&quot;))

    v_prof_par(v_max, max_depth) = w -&gt; let (v, s) = v_prof(v_max, max_depth, w)
        (Vec2(v, 0.0u&quot;m/yr&quot;), Vec2(s, 0.0u&quot;1/yr&quot;))
    end

    function main()
        CairoMakie.activate!()

        fig = Figure(size=(1000, 500))
        ax1 = Axis(fig[1, 1], xlabel=&quot;x (km)&quot;, ylabel=&quot;η (m)&quot;)
        input1 = transport_test_input(
            initial_topography = (x, y) -&gt; -x / 375.0 - 10u&quot;m&quot;,
            initial_sediment = 10.0u&quot;m&quot;,
            disintegration_rate = 50.0u&quot;m/Myr&quot;,
            diffusion_coefficient = 5.0u&quot;m/yr&quot;,
            wave_velocity = v_const(-0.5u&quot;m/yr&quot;)
        )
        plot_1d_evolution!(ax1, input1, 250)

        ax2 = Axis(fig[1, 2], xlabel=&quot;x (km)&quot;, ylabel=&quot;η (m)&quot;)
        input2 = transport_test_input(
            initial_topography = (x, y) -&gt; -x / 375.0 - 10u&quot;m&quot;,
            initial_sediment = 10.0u&quot;m&quot;,
            disintegration_rate = 50.0u&quot;m/Myr&quot;,
            diffusion_coefficient = 5.0u&quot;m/yr&quot;,
            wave_velocity = v_prof_par(-0.5u&quot;m/yr&quot;, 20u&quot;m&quot;)
        )
        plot_1d_evolution!(ax2, input2, 250)

        Legend(fig[1, 3], ax2)
        save(&quot;docs/src/_fig/1d-onshore.svg&quot;, fig)
    end
end

Script.main()</code></pre><h2 id="Active-Layer-Component"><a class="docs-heading-anchor" href="#Active-Layer-Component">Active Layer Component</a><a id="Active-Layer-Component-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Layer-Component" title="Permalink"></a></h2><div class="component-dag" style="overflow: scroll"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.50.0 (20211204.2007)
 -->
<!-- Pages: 1 -->
<svg width="800pt" height="431pt"
 viewBox="0.00 0.00 800.00 431.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 427)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-427 796,-427 796,4 -4,4"/>
<!-- TimeIntegration -->
<g id="node1" class="node">
<title>TimeIntegration</title>
<path fill="none" stroke="black" d="M210,-423C210,-423 72,-423 72,-423 66,-423 60,-417 60,-411 60,-411 60,-356 60,-356 60,-350 66,-344 72,-344 72,-344 210,-344 210,-344 216,-344 222,-350 222,-356 222,-356 222,-411 222,-411 222,-417 216,-423 210,-423"/>
<polyline fill="none" stroke="black" points="67,-392.5 215,-392.5 "/>
<text text-anchor="start" x="75.5" y="-401.3" font-family="Times,serif" font-weight="bold" font-size="14.00">TimeIntegration</text>
<polygon fill="#cccccc" stroke="transparent" points="67,-369.5 67,-392.5 114,-392.5 114,-369.5 67,-369.5"/>
<polyline fill="none" stroke="black" points="67,-369.5 114,-369.5 114,-392.5 67,-392.5 "/>
<text text-anchor="start" x="71" y="-377.3" font-family="Times,serif" font-size="14.00">Input</text>
<polygon fill="#cccccc" stroke="transparent" points="114,-369.5 114,-392.5 168,-392.5 168,-369.5 114,-369.5"/>
<polygon fill="none" stroke="black" points="114,-369.5 114,-392.5 168,-392.5 168,-369.5 114,-369.5"/>
<text text-anchor="start" x="118" y="-377.3" font-family="Times,serif" font-size="14.00">Facies</text>
<polygon fill="#cccccc" stroke="transparent" points="168,-369.5 168,-392.5 215,-392.5 215,-369.5 168,-369.5"/>
<polyline fill="none" stroke="black" points="215,-392.5 168,-392.5 168,-369.5 215,-369.5 "/>
<text text-anchor="start" x="172" y="-377.3" font-family="Times,serif" font-size="14.00">State</text>
<polyline fill="none" stroke="black" points="114,-350.5 114,-369.5 "/>
<text text-anchor="start" x="71" y="-357.5" font-family="monospace" font-size="10.00">time</text>
<polyline fill="none" stroke="black" points="168,-350.5 168,-369.5 "/>
<text text-anchor="start" x="118" y="-357.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="171" y="-357.5" font-family="monospace" font-size="10.00">step</text>
</g>
<!-- WaterDepth -->
<g id="node2" class="node">
<title>WaterDepth</title>
<path fill="none" stroke="black" d="M270,-308C270,-308 12,-308 12,-308 6,-308 0,-302 0,-296 0,-296 0,-203 0,-203 0,-197 6,-191 12,-191 12,-191 270,-191 270,-191 276,-191 282,-197 282,-203 282,-203 282,-296 282,-296 282,-302 276,-308 270,-308"/>
<polyline fill="none" stroke="black" points="7,-277.5 275,-277.5 "/>
<text text-anchor="start" x="93.5" y="-286.3" font-family="Times,serif" font-weight="bold" font-size="14.00">WaterDepth</text>
<polygon fill="#cccccc" stroke="transparent" points="7,-254.5 7,-277.5 124,-277.5 124,-254.5 7,-254.5"/>
<polyline fill="none" stroke="black" points="7,-254.5 124,-254.5 124,-277.5 7,-277.5 "/>
<text text-anchor="start" x="11" y="-262.3" font-family="Times,serif" font-size="14.00">Input</text>
<polygon fill="#cccccc" stroke="transparent" points="124,-254.5 124,-277.5 178,-277.5 178,-254.5 124,-254.5"/>
<polygon fill="none" stroke="black" points="124,-254.5 124,-277.5 178,-277.5 178,-254.5 124,-254.5"/>
<text text-anchor="start" x="128" y="-262.3" font-family="Times,serif" font-size="14.00">Facies</text>
<polygon fill="#cccccc" stroke="transparent" points="178,-254.5 178,-277.5 275,-277.5 275,-254.5 178,-254.5"/>
<polyline fill="none" stroke="black" points="275,-277.5 178,-277.5 178,-254.5 275,-254.5 "/>
<text text-anchor="start" x="182" y="-262.3" font-family="Times,serif" font-size="14.00">State</text>
<polyline fill="none" stroke="black" points="124,-235.5 124,-254.5 "/>
<text text-anchor="start" x="11" y="-242.5" font-family="monospace" font-size="10.00">sea_level</text>
<polyline fill="none" stroke="black" points="178,-235.5 178,-254.5 "/>
<text text-anchor="start" x="128" y="-242.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="181" y="-242.5" font-family="monospace" font-size="10.00">sediment_height</text>
<polyline fill="none" stroke="black" points="124,-216.5 124,-235.5 "/>
<text text-anchor="start" x="11" y="-223.5" font-family="monospace" font-size="10.00">initial_topography</text>
<polyline fill="none" stroke="black" points="178,-216.5 178,-235.5 "/>
<text text-anchor="start" x="128" y="-223.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="181" y="-223.5" font-family="monospace" font-size="10.00"> </text>
<polyline fill="none" stroke="black" points="124,-197.5 124,-216.5 "/>
<text text-anchor="start" x="11" y="-204.5" font-family="monospace" font-size="10.00">subsidence_rate</text>
<polyline fill="none" stroke="black" points="178,-197.5 178,-216.5 "/>
<text text-anchor="start" x="128" y="-204.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="181" y="-204.5" font-family="monospace" font-size="10.00"> </text>
</g>
<!-- TimeIntegration&#45;&gt;WaterDepth -->
<g id="edge1" class="edge">
<title>TimeIntegration&#45;&gt;WaterDepth</title>
<path fill="none" stroke="black" d="M141,-343.97C141,-335.98 141,-327.34 141,-318.65"/>
<polygon fill="black" stroke="black" points="144.5,-318.47 141,-308.47 137.5,-318.47 144.5,-318.47"/>
</g>
<!-- ActiveLayer -->
<g id="node6" class="node">
<title>ActiveLayer</title>
<path fill="none" stroke="black" d="M544.5,-155C544.5,-155 217.5,-155 217.5,-155 211.5,-155 205.5,-149 205.5,-143 205.5,-143 205.5,-12 205.5,-12 205.5,-6 211.5,0 217.5,0 217.5,0 544.5,0 544.5,0 550.5,0 556.5,-6 556.5,-12 556.5,-12 556.5,-143 556.5,-143 556.5,-149 550.5,-155 544.5,-155"/>
<polyline fill="none" stroke="black" points="213,-124.5 550,-124.5 "/>
<text text-anchor="start" x="335.5" y="-133.3" font-family="Times,serif" font-weight="bold" font-size="14.00">ActiveLayer</text>
<polygon fill="#cccccc" stroke="transparent" points="213,-101.5 213,-124.5 336,-124.5 336,-101.5 213,-101.5"/>
<polyline fill="none" stroke="black" points="213,-101.5 336,-101.5 336,-124.5 213,-124.5 "/>
<text text-anchor="start" x="217" y="-109.3" font-family="Times,serif" font-size="14.00">Input</text>
<polygon fill="#cccccc" stroke="transparent" points="336,-101.5 336,-124.5 471,-124.5 471,-101.5 336,-101.5"/>
<polygon fill="none" stroke="black" points="336,-101.5 336,-124.5 471,-124.5 471,-101.5 336,-101.5"/>
<text text-anchor="start" x="340" y="-109.3" font-family="Times,serif" font-size="14.00">Facies</text>
<polygon fill="#cccccc" stroke="transparent" points="471,-101.5 471,-124.5 550,-124.5 550,-101.5 471,-101.5"/>
<polyline fill="none" stroke="black" points="550,-124.5 471,-124.5 471,-101.5 550,-101.5 "/>
<text text-anchor="start" x="475" y="-109.3" font-family="Times,serif" font-size="14.00">State</text>
<polyline fill="none" stroke="black" points="336,-82.5 336,-101.5 "/>
<text text-anchor="start" x="217" y="-89.5" font-family="monospace" font-size="10.00">intertidal_zone</text>
<polyline fill="none" stroke="black" points="471,-82.5 471,-101.5 "/>
<text text-anchor="start" x="340" y="-89.5" font-family="monospace" font-size="10.00">diffusion_coefficient</text>
<text text-anchor="start" x="474" y="-89.5" font-family="monospace" font-size="10.00">active_layer</text>
<polyline fill="none" stroke="black" points="336,-63.5 336,-82.5 "/>
<text text-anchor="start" x="217" y="-70.5" font-family="monospace" font-size="10.00">disintegration_rate</text>
<polyline fill="none" stroke="black" points="471,-63.5 471,-82.5 "/>
<text text-anchor="start" x="340" y="-70.5" font-family="monospace" font-size="10.00">wave_velocity</text>
<text text-anchor="start" x="474" y="-70.5" font-family="monospace" font-size="10.00"> </text>
<polyline fill="none" stroke="black" points="336,-44.5 336,-63.5 "/>
<text text-anchor="start" x="217" y="-51.5" font-family="monospace" font-size="10.00">cementation_time</text>
<polyline fill="none" stroke="black" points="471,-44.5 471,-63.5 "/>
<text text-anchor="start" x="340" y="-51.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="474" y="-51.5" font-family="monospace" font-size="10.00"> </text>
<polyline fill="none" stroke="black" points="336,-25.5 336,-44.5 "/>
<text text-anchor="start" x="217" y="-32.5" font-family="monospace" font-size="10.00">transport_solver</text>
<polyline fill="none" stroke="black" points="471,-25.5 471,-44.5 "/>
<text text-anchor="start" x="340" y="-32.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="474" y="-32.5" font-family="monospace" font-size="10.00"> </text>
<polyline fill="none" stroke="black" points="336,-6.5 336,-25.5 "/>
<text text-anchor="start" x="217" y="-13.5" font-family="monospace" font-size="10.00">transport_substeps</text>
<polyline fill="none" stroke="black" points="471,-6.5 471,-25.5 "/>
<text text-anchor="start" x="340" y="-13.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="474" y="-13.5" font-family="monospace" font-size="10.00"> </text>
</g>
<!-- WaterDepth&#45;&gt;ActiveLayer -->
<g id="edge4" class="edge">
<title>WaterDepth&#45;&gt;ActiveLayer</title>
<path fill="none" stroke="black" d="M222.25,-190.95C235.78,-181.36 250.04,-171.26 264.25,-161.2"/>
<polygon fill="black" stroke="black" points="266.46,-163.92 272.6,-155.29 262.41,-158.21 266.46,-163.92"/>
</g>
<!-- Boxes -->
<g id="node3" class="node">
<title>Boxes</title>
<path fill="none" stroke="black" d="M547,-423C547,-423 409,-423 409,-423 403,-423 397,-417 397,-411 397,-411 397,-356 397,-356 397,-350 403,-344 409,-344 409,-344 547,-344 547,-344 553,-344 559,-350 559,-356 559,-356 559,-411 559,-411 559,-417 553,-423 547,-423"/>
<polyline fill="none" stroke="black" points="404,-392.5 552,-392.5 "/>
<text text-anchor="start" x="454.5" y="-401.3" font-family="Times,serif" font-weight="bold" font-size="14.00">Boxes</text>
<polygon fill="#cccccc" stroke="transparent" points="404,-369.5 404,-392.5 451,-392.5 451,-369.5 404,-369.5"/>
<polyline fill="none" stroke="black" points="404,-369.5 451,-369.5 451,-392.5 404,-392.5 "/>
<text text-anchor="start" x="408" y="-377.3" font-family="Times,serif" font-size="14.00">Input</text>
<polygon fill="#cccccc" stroke="transparent" points="451,-369.5 451,-392.5 505,-392.5 505,-369.5 451,-369.5"/>
<polygon fill="none" stroke="black" points="451,-369.5 451,-392.5 505,-392.5 505,-369.5 451,-369.5"/>
<text text-anchor="start" x="455" y="-377.3" font-family="Times,serif" font-size="14.00">Facies</text>
<polygon fill="#cccccc" stroke="transparent" points="505,-369.5 505,-392.5 552,-392.5 552,-369.5 505,-369.5"/>
<polyline fill="none" stroke="black" points="552,-392.5 505,-392.5 505,-369.5 552,-369.5 "/>
<text text-anchor="start" x="509" y="-377.3" font-family="Times,serif" font-size="14.00">State</text>
<polyline fill="none" stroke="black" points="451,-350.5 451,-369.5 "/>
<text text-anchor="start" x="408" y="-357.5" font-family="monospace" font-size="10.00">box</text>
<polyline fill="none" stroke="black" points="505,-350.5 505,-369.5 "/>
<text text-anchor="start" x="455" y="-357.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="508" y="-357.5" font-family="monospace" font-size="10.00"> </text>
</g>
<!-- Boxes&#45;&gt;WaterDepth -->
<g id="edge2" class="edge">
<title>Boxes&#45;&gt;WaterDepth</title>
<path fill="none" stroke="black" d="M396.85,-350.71C365.3,-338.35 328.09,-323.78 291.97,-309.63"/>
<polygon fill="black" stroke="black" points="292.91,-306.24 282.32,-305.85 290.35,-312.76 292.91,-306.24"/>
</g>
<!-- SedimentBuffer -->
<g id="node5" class="node">
<title>SedimentBuffer</title>
<path fill="none" stroke="black" d="M780,-298.5C780,-298.5 492,-298.5 492,-298.5 486,-298.5 480,-292.5 480,-286.5 480,-286.5 480,-212.5 480,-212.5 480,-206.5 486,-200.5 492,-200.5 492,-200.5 780,-200.5 780,-200.5 786,-200.5 792,-206.5 792,-212.5 792,-212.5 792,-286.5 792,-286.5 792,-292.5 786,-298.5 780,-298.5"/>
<polyline fill="none" stroke="black" points="487,-268.5 785,-268.5 "/>
<text text-anchor="start" x="573" y="-277.3" font-family="Times,serif" font-weight="bold" font-size="14.00">SedimentBuffer</text>
<polygon fill="#cccccc" stroke="transparent" points="487,-245.5 487,-268.5 634,-268.5 634,-245.5 487,-245.5"/>
<polyline fill="none" stroke="black" points="487,-245.5 634,-245.5 634,-268.5 487,-268.5 "/>
<text text-anchor="start" x="491" y="-253.3" font-family="Times,serif" font-size="14.00">Input</text>
<polygon fill="#cccccc" stroke="transparent" points="634,-245.5 634,-268.5 688,-268.5 688,-245.5 634,-245.5"/>
<polygon fill="none" stroke="black" points="634,-245.5 634,-268.5 688,-268.5 688,-245.5 634,-245.5"/>
<text text-anchor="start" x="638" y="-253.3" font-family="Times,serif" font-size="14.00">Facies</text>
<polygon fill="#cccccc" stroke="transparent" points="688,-245.5 688,-268.5 785,-268.5 785,-245.5 688,-245.5"/>
<polyline fill="none" stroke="black" points="785,-268.5 688,-268.5 688,-245.5 785,-245.5 "/>
<text text-anchor="start" x="692" y="-253.3" font-family="Times,serif" font-size="14.00">State</text>
<polyline fill="none" stroke="black" points="634,-226.5 634,-245.5 "/>
<text text-anchor="start" x="491" y="-233.5" font-family="monospace" font-size="10.00">sediment_buffer_size</text>
<polyline fill="none" stroke="black" points="688,-226.5 688,-245.5 "/>
<text text-anchor="start" x="638" y="-233.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="691" y="-233.5" font-family="monospace" font-size="10.00">sediment_buffer</text>
<polyline fill="none" stroke="black" points="634,-207.5 634,-226.5 "/>
<text text-anchor="start" x="491" y="-214.5" font-family="monospace" font-size="10.00">depositional_resolution</text>
<polyline fill="none" stroke="black" points="688,-207.5 688,-226.5 "/>
<text text-anchor="start" x="638" y="-214.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="691" y="-214.5" font-family="monospace" font-size="10.00"> </text>
</g>
<!-- Boxes&#45;&gt;SedimentBuffer -->
<g id="edge3" class="edge">
<title>Boxes&#45;&gt;SedimentBuffer</title>
<path fill="none" stroke="black" d="M524.12,-343.97C538.55,-331.91 554.76,-318.37 570.27,-305.42"/>
<polygon fill="black" stroke="black" points="572.87,-307.81 578.3,-298.71 568.38,-302.43 572.87,-307.81"/>
</g>
<!-- FaciesBase -->
<g id="node4" class="node">
<title>FaciesBase</title>
<path fill="none" stroke="black" d="M450,-289C450,-289 312,-289 312,-289 306,-289 300,-283 300,-277 300,-277 300,-222 300,-222 300,-216 306,-210 312,-210 312,-210 450,-210 450,-210 456,-210 462,-216 462,-222 462,-222 462,-277 462,-277 462,-283 456,-289 450,-289"/>
<polyline fill="none" stroke="black" points="307,-258.5 455,-258.5 "/>
<text text-anchor="start" x="337" y="-267.3" font-family="Times,serif" font-weight="bold" font-size="14.00">FaciesBase</text>
<polygon fill="#cccccc" stroke="transparent" points="307,-235.5 307,-258.5 354,-258.5 354,-235.5 307,-235.5"/>
<polyline fill="none" stroke="black" points="307,-235.5 354,-235.5 354,-258.5 307,-258.5 "/>
<text text-anchor="start" x="311" y="-243.3" font-family="Times,serif" font-size="14.00">Input</text>
<polygon fill="#cccccc" stroke="transparent" points="354,-235.5 354,-258.5 408,-258.5 408,-235.5 354,-235.5"/>
<polygon fill="none" stroke="black" points="354,-235.5 354,-258.5 408,-258.5 408,-235.5 354,-235.5"/>
<text text-anchor="start" x="358" y="-243.3" font-family="Times,serif" font-size="14.00">Facies</text>
<polygon fill="#cccccc" stroke="transparent" points="408,-235.5 408,-258.5 455,-258.5 455,-235.5 408,-235.5"/>
<polyline fill="none" stroke="black" points="455,-258.5 408,-258.5 408,-235.5 455,-235.5 "/>
<text text-anchor="start" x="412" y="-243.3" font-family="Times,serif" font-size="14.00">State</text>
<polyline fill="none" stroke="black" points="354,-216.5 354,-235.5 "/>
<text text-anchor="start" x="311" y="-223.5" font-family="monospace" font-size="10.00">facies</text>
<polyline fill="none" stroke="black" points="408,-216.5 408,-235.5 "/>
<text text-anchor="start" x="358" y="-223.5" font-family="monospace" font-size="10.00"> </text>
<text text-anchor="start" x="411" y="-223.5" font-family="monospace" font-size="10.00"> </text>
</g>
<!-- FaciesBase&#45;&gt;ActiveLayer -->
<g id="edge5" class="edge">
<title>FaciesBase&#45;&gt;ActiveLayer</title>
<path fill="none" stroke="black" d="M381,-209.92C381,-196.58 381,-181.04 381,-165.42"/>
<polygon fill="black" stroke="black" points="384.5,-165.16 381,-155.16 377.5,-165.16 384.5,-165.16"/>
</g>
<!-- SedimentBuffer&#45;&gt;ActiveLayer -->
<g id="edge6" class="edge">
<title>SedimentBuffer&#45;&gt;ActiveLayer</title>
<path fill="none" stroke="black" d="M563.95,-200.47C545.31,-188.04 524.71,-174.3 504.25,-160.67"/>
<polygon fill="black" stroke="black" points="506.07,-157.67 495.81,-155.04 502.19,-163.5 506.07,-157.67"/>
</g>
</g>
</svg>
</div><div class="noweb-label">file:<i>src/Components/ActiveLayer.jl</i></div><pre><code class="language- julia hljs">@compose module ActiveLayer
@mixin WaterDepth, FaciesBase, SedimentBuffer

export disintegrator, transporter, cementation_factor

using ..Common
using CarboKitten.Transport.Advection: transport, advection_coef!, transport_dC!, max_dt
using CarboKitten.Transport.Solvers: runge_kutta_4, forward_euler
using Unitful
using GeometryBasics

@kwdef struct Facies &lt;: AbstractFacies
    diffusion_coefficient::typeof(1.0u&quot;m/yr&quot;) = 0.0u&quot;m/Myr&quot;
    wave_velocity = _ -&gt; (Vec2(0.0u&quot;m/Myr&quot;, 0.0u&quot;m/Myr&quot;), Vec2(0.0u&quot;1/Myr&quot;, 0.0u&quot;1/Myr&quot;))
end

@kwdef mutable struct State &lt;: AbstractState
    active_layer::Array{Amount,3}
end

@kwdef struct Input &lt;: AbstractInput
    intertidal_zone::Height = 0.0u&quot;m&quot;
    disintegration_rate::Rate = 50.0u&quot;m/Myr&quot;
    cementation_time::Union{typeof(1.0u&quot;Myr&quot;),Nothing} = nothing
    transport_solver = Val{:RK4}
    transport_substeps = :adaptive
end

courant_max(::Type{Val{:RK4}}) = 2.0
courant_max(::Type{Val{:forward_euler}}) = 1.0

transport_solver(f, _) = f
transport_solver(::Type{Val{:RK4}}, box) = runge_kutta_4(typeof(1.0u&quot;m&quot;), box)
transport_solver(::Type{Val{:forward_euler}}, _) = forward_euler

function cementation_factor(input::AbstractInput)
    if input.cementation_time === nothing
        return 1.0
    else
        return 1.0 - exp(input.time.Δt * log(1 / 2) / input.cementation_time)
    end
end

function adaptive_transporter(input)
    solver = transport_solver(input.transport_solver, input.box)

    w = water_depth(input)
    box = input.box
    Δt = input.time.Δt  # / input.transport_substeps
    fs = input.facies
    adv = Matrix{Vec2{Rate}}(undef, box.grid_size...)
    rct = Matrix{typeof(1.0u&quot;1/Myr&quot;)}(undef, box.grid_size...)
    dC = Matrix{Rate}(undef, box.grid_size...)
    cm = courant_max(input.transport_solver)
    iz = input.intertidal_zone

    return function (state)
        wd = w(state)
        wd .+= iz

        C = state.active_layer
        for (i, f) in pairs(fs)
            advection_coef!(box, f.diffusion_coefficient, f.wave_velocity, wd, adv, rct)
            m = max_dt(adv, box.phys_scale, cm)
            steps = ceil(Int, Δt / m)

            # @debug &quot;step $(state.step) - transport substeps $(steps)&quot;
            subdt = Δt / steps
            for j in 1:steps
                solver(
                    (C, _) -&gt; transport_dC!(input.box, adv, rct, C, dC),
                    view(C, i, :, :), TimeIntegration.time(input, state), subdt)
            end
        end

        for i in eachindex(C)
            if C[i] &lt; zero(Amount)
                C[i] = zero(Amount)
            end
        end
    end
end

&quot;&quot;&quot;
    disintegrator(input) -&gt; f!

Prepares the disintegration step. Returns a function `f!(state::State)`. The returned function
modifies the state, popping sediment from the `sediment_buffer` and returns an array of `Amount`.
&quot;&quot;&quot;
function disintegrator(input)
    max_h = input.disintegration_rate * input.time.Δt
    w = water_depth(input)
    output = Array{Float64,3}(undef, n_facies(input), input.box.grid_size...)
    depositional_resolution = input.depositional_resolution
    iz = input.intertidal_zone

    return function (state)
        wn = w(state)
        wn .+= iz
        h = min.(max_h, state.sediment_height)
        h[wn.&lt;=0.0u&quot;m&quot;] .= 0.0u&quot;m&quot;

        @assert all(h .&lt;= max_h)
        state.sediment_height .-= h
        pop_sediment!(state.sediment_buffer, h ./ depositional_resolution .|&gt; NoUnits, output)
        return output .* depositional_resolution
    end
end

&quot;&quot;&quot;
    transporter(input::Input) -&gt; f

Prepares the transportation step. Returns a function `f(state::State, active_layer)`,
transporting the active layer, returning a transported `Amount` of sediment.
&quot;&quot;&quot;
function transporter(input)
    if input.transport_substeps == :adaptive
        return adaptive_transporter(input)
    end

    solver = transport_solver(input.transport_solver, input.box)

    w = water_depth(input)
    box = input.box
    Δt = input.time.Δt / input.transport_substeps
    steps = input.transport_substeps
    fs = input.facies
    iz = input.intertidal_zone

    return function (state)
        wd = w(state)
        wd .+= iz

        C = state.active_layer
        for (i, f) in pairs(fs)
            for j in 1:steps
                solver(
                    (C, _) -&gt; transport(
                        input.box, f.diffusion_coefficient, f.wave_velocity,
                        C, wd),
                    view(C, i, :, :), TimeIntegration.time(input, state), Δt)
            end
        end

        for i in eachindex(C)
            if C[i] &lt; zero(Amount)
                C[i] = zero(Amount)
            end
        end
    end
end

function write_header(input::AbstractInput, output::AbstractOutput)
    set_attribute(output, &quot;intertidal_zone&quot;, input.intertidal_zone |&gt; in_units_of(u&quot;m&quot;))
    set_attribute(output, &quot;disintegration_rate&quot;, input.disintegration_rate |&gt; in_units_of(u&quot;m/Myr&quot;))
    if input.cementation_time !== nothing
        set_attribute(output, &quot;cementation_time&quot;, input.cementation_time |&gt; in_units_of(u&quot;Myr&quot;))
    end
end

end</code></pre><h2 id="Intertidal-zone"><a class="docs-heading-anchor" href="#Intertidal-zone">Intertidal zone</a><a id="Intertidal-zone-1"></a><a class="docs-heading-anchor-permalink" href="#Intertidal-zone" title="Permalink"></a></h2><p>You may pass the <code>intertidal_zone</code> argument to define a height above sea-level where sediment is still transported.</p><p>The following test has three sediment peaks, one below sea-level, one in the intertidal zone and one above the intertidal zone. In the latter two cases, sediment is transported.</p><p>The <code>transport_test_input</code> has a box of <span>$120 \times 1$</span> with a resolution of 125m (15km total). We divide the domain into three sections: dry (<span>$h &gt; 10m$</span>), intertidal (<span>$10m &gt; h &gt; 0m$</span>) and wet zones (<span>$0m &gt; h$</span>). The dry zone never has transport, the wet zone always has transport, but the intertidal zone only has transport enabled when we set <code>intertidal_zone</code> to <code>10u&quot;m&quot;</code>.</p><p><img src="../fig/1d-intertidal.svg" alt="intertidal zone test"/></p><div class="noweb-label">file:<i>examples/transport/1d-intertidal-zone.jl</i></div><pre><code class="language- julia hljs">#| creates: docs/src/_fig/1d-intertidal.svg
#| collect: figures

module Script
    using CarboKitten
    using CarboKitten.Testing: transport_test_input
    using CairoMakie

    include(&quot;plot-1d-evolution.jl&quot;)

    function three_peaks(x, y)
        sum(exp(-(x-μ)^2 / (2 * (0.5u&quot;km&quot;)^2)) * 9.0u&quot;m&quot;
            for μ in [2.5u&quot;km&quot;, 7.5u&quot;km&quot;, 12.5u&quot;km&quot;])
    end

    function staircase(dx, dy, y0)
        return function (x, _)
            floor(x / dx) * dy + y0
        end
    end

    v_const(v_max) = _ -&gt; (Vec2(v_max, 0.0u&quot;m/yr&quot;), Vec2(0.0u&quot;1/yr&quot;, 0.0u&quot;1/yr&quot;))

    function main()
        CairoMakie.activate!()

        input = transport_test_input(
            initial_topography = staircase(5.0u&quot;km&quot;, -10.0u&quot;m&quot;, 10.0u&quot;m&quot;),
            initial_sediment = three_peaks,
            disintegration_rate = 50000.0u&quot;m/Myr&quot;,
            wave_velocity = v_const(-1u&quot;km/Myr&quot;),
            intertidal_zone = 10u&quot;m&quot;
        )

        fig = plot_1d_evolution(input, 500)
        save(&quot;docs/src/_fig/1d-intertidal.svg&quot;, fig)
    end
end

Script.main()</code></pre><p>The following tests that we see the expected behaviours both without an intertidal zone (<code>input1</code>) and with (<code>input1</code>). The regions split at grid locations 40 and 80, so we test slices <code>10:30</code>, <code>50:70</code> and <code>90:110</code>. This ommits the boundaries where numeric artifacts could be encountered.</p><div class="noweb-label">file:<i>test/Transport/IntertidalZoneSpec.jl</i></div><pre><code class="language- julia hljs">@testset &quot;CarboKitten.Transport.IntertidalZone&quot; begin
    using CarboKitten
    using CarboKitten.Testing: transport_test_input

    function end_sediment_height(input)
        state = ALCAP.initial_state(input)
        run_model((_, _) -&gt; (), Model{ALCAP}, input, state)
        return state.sediment_height
    end

    function three_peaks(x, y)
        sum(exp(-(x-μ)^2 / (2 * (0.5u&quot;km&quot;)^2)) * 9.0u&quot;m&quot;
            for μ in [2.5u&quot;km&quot;, 7.5u&quot;km&quot;, 12.5u&quot;km&quot;])
    end

    function staircase(dx, dy, y0)
        return function (x, _)
            floor(x / dx) * dy + y0
        end
    end

    v_const(v_max) = _ -&gt; (Vec2(v_max, 0.0u&quot;m/yr&quot;), Vec2(0.0u&quot;1/yr&quot;, 0.0u&quot;1/yr&quot;))

    input1 = transport_test_input(
        initial_topography = staircase(5.0u&quot;km&quot;, -10.0u&quot;m&quot;, 10.0u&quot;m&quot;),
        initial_sediment = three_peaks,
        disintegration_rate = 50000.0u&quot;m/Myr&quot;,
        wave_velocity = v_const(-1u&quot;km/Myr&quot;),
        intertidal_zone = 0u&quot;m&quot;
    )

    output1 = end_sediment_height(input1)[:, 1]

    input2 = transport_test_input(
        initial_topography = staircase(5.0u&quot;km&quot;, -10.0u&quot;m&quot;, 10.0u&quot;m&quot;),
        initial_sediment = three_peaks,
        disintegration_rate = 50000.0u&quot;m/Myr&quot;,
        wave_velocity = v_const(-1u&quot;km/Myr&quot;),
        intertidal_zone = 10u&quot;m&quot;
    )

    output2 = end_sediment_height(input2)[:, 1]

    @test output1[10:30] ≈ output1[50:70] atol=0.01u&quot;m&quot;
    @test !isapprox(output1[50:70], output1[90:110], atol=1.0u&quot;m&quot;)

    @test !isapprox(output2[10:30], output2[50:70], atol=1.0u&quot;m&quot;)
    @test output2[50:70] ≈ output2[90:110] atol=0.01u&quot;m&quot;
end</code></pre><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Literature on active (or mixing) layer transport modeling is vast. Most of which is concerned with much smaller time scales, and more complicated physics than we are mostly dealing with.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Note that in other approaches to active layer transport, like Paola 1992, there would be a factor <span>$1/C_f$</span>. Here we have a different interpretation to what the concentration means: the sediment settles down after transport, such that the concentration has no impact on the change in sediment surface elevation.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../components/sediment_buffer/">« Sediment Buffers</a><a class="docs-footer-nextpage" href="../onshore-transport/">Onshore Transport »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 10 October 2025 20:09">Friday 10 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
