<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Output to Memory · CarboKitten</title><meta name="title" content="Output to Memory · CarboKitten"/><meta property="og:title" content="Output to Memory · CarboKitten"/><meta property="twitter:title" content="Output to Memory · CarboKitten"/><meta name="description" content="Documentation for CarboKitten."/><meta property="og:description" content="Documentation for CarboKitten."/><meta property="twitter:description" content="Documentation for CarboKitten."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="CarboKitten logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CarboKitten</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../getting-started/">Getting started</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../bosscher-1992/">Bosscher and Schlager 1992</a></li><li><a class="tocitem" href="../../ca-with-production/">Model with CA and Production</a></li><li><a class="tocitem" href="../../model-alcap/">ALCAPS</a></li><li><a class="tocitem" href="../../models/without-ca/">Model without CA</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../first_tutorial/">Tutorial (Pluto notebook)</a></li><li><a class="tocitem" href="../../cases/tabular-sea-level/">Tabular Sea Levels</a></li><li><a class="tocitem" href="../../initial-topography/">Initial Topography</a></li></ul></li><li><a class="tocitem" href="../../architecture/">Architecture</a></li><li><span class="tocitem">Model Components</span><ul><li><a class="tocitem" href="../../components/components/">Components</a></li><li><a class="tocitem" href="../../components/tag/">Tags</a></li><li><a class="tocitem" href="../../components/boxes/">Boxes</a></li><li><a class="tocitem" href="../../components/time/">Time</a></li><li><a class="tocitem" href="../../components/output/">Output</a></li><li><a class="tocitem" href="../../components/facies/">Facies</a></li><li><a class="tocitem" href="../../components/cellular-automata/">Cellular Automata</a></li><li><a class="tocitem" href="../../components/waterdepth/">Water Depth</a></li><li><a class="tocitem" href="../../components/production/">Production</a></li><li><a class="tocitem" href="../../components/sediment_buffer/">Sediment Buffers</a></li><li><a class="tocitem" href="../../active-layer-transport/">Active Layer Transport</a></li><li><a class="tocitem" href="../../onshore-transport/">Onshore Transport</a></li></ul></li><li><a class="tocitem" href="../../visualization/">Visualizations</a></li><li><span class="tocitem">CarboCAT</span><ul><li><a class="tocitem" href="../../carbocat/">Summary</a></li></ul></li><li><span class="tocitem">Denudation</span><ul><li><a class="tocitem" href="../../denudation/denudation/">Denudation</a></li><li><a class="tocitem" href="../../denudation/empirical/">Empirical Denudation</a></li><li><a class="tocitem" href="../../denudation/chemical/">Chemical Dissolution</a></li><li><a class="tocitem" href="../../denudation/physical_erosion/">Physical Erosion</a></li></ul></li><li><span class="tocitem">Input &amp; Output</span><ul><li><a class="tocitem" href="../../input-methods/">Input Methods</a></li><li><a class="tocitem" href="../abstract/">Output</a></li><li><a class="tocitem" href="../h5writer/">HDF5 Output</a></li><li class="is-active"><a class="tocitem" href>Output to Memory</a><ul class="internal"><li><a class="tocitem" href="#Full-example"><span>Full example</span></a></li><li><a class="tocitem" href="#Data-Structures"><span>Data Structures</span></a></li><li><a class="tocitem" href="#Memory-Writer"><span>Memory Writer</span></a></li><li><a class="tocitem" href="#Tests"><span>Tests</span></a></li></ul></li><li><a class="tocitem" href="../../data-export/">CSV Export</a></li><li><a class="tocitem" href="../../debugging/">Trouble shooting and diagnostics</a></li></ul></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../../unitful/">Unitful</a></li><li><a class="tocitem" href="../../boxes/">Boxes</a></li><li><a class="tocitem" href="../../stencils/">Stencils</a></li><li><a class="tocitem" href="../../utility/">Utility</a></li><li><a class="tocitem" href="../../finite-difference-transport/">Finite Difference</a></li></ul></li><li><a class="tocitem" href="../../api/">API Documentation</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Input &amp; Output</a></li><li class="is-active"><a href>Output to Memory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Output to Memory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MindTheGap-ERC/CarboKitten.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MindTheGap-ERC/CarboKitten.jl/blob/main/docs/transpiled/output/memory-writer.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h1><p>There are two options for writing output: to HDF5 and memory. To write to an HDF5 file, you may run:</p><pre><code class="language-julia hljs">run_model(Model{M}, input, &quot;my_hdf5_output.h5&quot;)</code></pre><p>In cases where you don&#39;t want to write output immediately, you can output to memory:</p><pre><code class="language-julia hljs">result = run_model(Model{M}, input, new_output(MemoryOutput))</code></pre><p>The <code>result</code> is of type <code>MemoryOutput</code> and contains a <code>header</code> field as well as <code>data_volumes</code>, <code>data_slices</code> and <code>data_columns</code>, containing data sets for each <code>OutputSpec</code> that you configured in <code>input.output</code>. Assuming the default, there will be a <code>DataVolume</code> with name <code>:full</code>.</p><pre><code class="language-julia hljs">header, data = (result.header, result.data_volumes[:full])</code></pre><p>Or, in case you write to HDF5:</p><pre><code class="language-julia hljs">header, data = read_volume(&quot;my_hdf5_output.h5&quot;, :full)</code></pre><p>You can always subscript a <code>DataVolume</code> into <code>DataSlice</code> or <code>DataColumn</code>.</p><pre><code class="language-julia hljs">data[:, 25] isa DataSlice
data[40, 25] isa DataColumn</code></pre><p>These can be used for subsequent visualization or CSV export.</p><h2 id="Full-example"><a class="docs-heading-anchor" href="#Full-example">Full example</a><a id="Full-example-1"></a><a class="docs-heading-anchor-permalink" href="#Full-example" title="Permalink"></a></h2><div class="noweb-label">file:<i>examples/autocycles.jl</i></div><pre><code class="language- julia hljs">module AutoCycles

using CarboKitten
using CarboKitten.Models: WithoutCA as M
using CarboKitten.Visualization: profile_plot!

using Makie
using CarboKitten: Box

v_const(v_max) = _ -&gt; (Vec2(v_max, 0.0u&quot;m/yr&quot;), Vec2(0.0u&quot;1/yr&quot;, 0.0u&quot;1/yr&quot;))

function run()
    CarboKitten.init()

    facies = [
        M.Facies(
            maximum_growth_rate=100.0u&quot;m/Myr&quot;,
            extinction_coefficient=0.8u&quot;m^-1&quot;,
            saturation_intensity=60u&quot;W/m^2&quot;,
            diffusion_coefficient=100.0u&quot;m/yr&quot;,
            wave_velocity=v_const(-5.0u&quot;m/yr&quot;)),
        M.Facies(
            maximum_growth_rate=20.0u&quot;m/Myr&quot;,
            extinction_coefficient=0.8u&quot;m^-1&quot;,
            saturation_intensity=60u&quot;W/m^2&quot;,
            diffusion_coefficient=10.0u&quot;m/yr&quot;,
            wave_velocity=v_const(0.0u&quot;m/yr&quot;))]


    input = M.Input(
        box=CarboKitten.Box{Coast}(grid_size=(500, 1), phys_scale=50.0u&quot;m&quot;),
        time=TimeProperties(
            Δt=20u&quot;yr&quot;,
            steps=40000),

        output=Dict(
            :profile =&gt; OutputSpec(slice = (:, 1), write_interval = 40),
            :col1 =&gt; OutputSpec(slice = (100, 1)),
            :col2 =&gt; OutputSpec(slice = (200, 1)),
            :col3 =&gt; OutputSpec(slice = (300, 1)),
            :col4 =&gt; OutputSpec(slice = (400, 1))),

        initial_topography=(x, y) -&gt; (15u&quot;km&quot; - x) / 300.0,
        sea_level=t -&gt; 0.0u&quot;m&quot;,

        subsidence_rate=50.0u&quot;m/Myr&quot;,
        disintegration_rate=100.0u&quot;m/Myr&quot;,
        cementation_time=50.0u&quot;yr&quot;,

        insolation=400.0u&quot;W/m^2&quot;,
        sediment_buffer_size=50,
        depositional_resolution=0.5u&quot;m&quot;,
        facies=facies,

        transport_solver=Val{:forward_euler},
        intertidal_zone=0.0u&quot;m&quot;)

    result = run_model(Model{M}, input, MemoryOutput(input))
end

function plot(result::MemoryOutput)
    header = result.header
    slice = result.data_slices[:profile]
    n_cols = length(result.data_columns)

	fig = Figure()
    ax1 = Axis(fig[1, 1:n_cols])

	x = header.axes.x
	t = header.axes.t

	plot = profile_plot!(ax1, header, slice; colorrange=(0.2, 1.0)) do x; x[1] / sum(x) end
    col_positions = [x[col.slice[1]] |&gt; in_units_of(u&quot;km&quot;) for col in values(result.data_columns)]
    vlines!(ax1, col_positions; color=:red)

    Colorbar(fig[1, n_cols+1], plot; label=L&quot;f_1 / f_{\textrm{total}}&quot;)

    col_names = sort!(collect(keys(result.data_columns)))
    for (i, k) in enumerate(col_names)
        f1 = result.data_columns[k].deposition[1,:]
        f2 = result.data_columns[k].deposition[2,:]
        f_total = f1 .+ f2
        ax = Axis(fig[2, i], title=string(k) * &quot; amount&quot;)
        lines!(ax, f1 |&gt; in_units_of(u&quot;m&quot;), t[1:end-1] |&gt; in_units_of(u&quot;Myr&quot;); label=&quot;facies 1&quot;)
        lines!(ax, f2 |&gt; in_units_of(u&quot;m&quot;), t[1:end-1] |&gt; in_units_of(u&quot;Myr&quot;); label=&quot;facies 2&quot;)
        lines!(ax, f_total |&gt; in_units_of(u&quot;m&quot;), t[1:end-1] |&gt; in_units_of(u&quot;Myr&quot;); label=&quot;total&quot;, color=:black, linewidth=2)
        axislegend(ax)
    end

	fig
end

end</code></pre><h2 id="Data-Structures"><a class="docs-heading-anchor" href="#Data-Structures">Data Structures</a><a id="Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures" title="Permalink"></a></h2><h2 id="Memory-Writer"><a class="docs-heading-anchor" href="#Memory-Writer">Memory Writer</a><a id="Memory-Writer-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Writer" title="Permalink"></a></h2><p>Sometimes we don&#39;t want to write to HDF5, but just get a <code>DataVolume</code> directly.</p><div class="noweb-label">file:<i>src/Output/MemoryWriter.jl</i></div><pre><code class="language- julia hljs">module MemoryWriter

using ..Abstract
import ..Abstract:
    new_output, add_data_set, set_attribute, write_sediment_thickness,
    write_production, write_disintegration, write_deposition
using ...Components.Common
using ...Components.WaterDepth: initial_topography
using ...CarboKitten: time_axis, box_axes, OutputSpec, AbstractOutput, AbstractInput, AbstractState

struct MemoryOutput &lt;: AbstractOutput
    header::Header
    data_volumes::Dict{Symbol,DataVolume}
    data_slices::Dict{Symbol,DataSlice}
    data_columns::Dict{Symbol,DataColumn}
end

MemoryOutput(input::AbstractInput) = new_output(MemoryOutput, input)

function new_output(::Type{MemoryOutput}, input::AbstractInput)
    t_axis = time_axis(input.time)
    x_axis, y_axis = box_axes(input.box)
    axes = Axes(x=x_axis, y=y_axis, t=t_axis)
    h0 = initial_topography(input)
    sl = input.sea_level.(t_axis)

    header = Header(
        tag=input.tag,
        axes=axes,
        Δt=input.time.Δt,
        time_steps=input.time.steps,
        grid_size=input.box.grid_size,
        n_facies=length(input.facies),
        initial_topography=h0,
        sea_level=sl,
        subsidence_rate=input.subsidence_rate,
        data_sets=Dict(),
        attributes=Dict())

    return MemoryOutput(header, Dict(), Dict(), Dict())
end

axis_size(::Colon, a::Int) = a
axis_size(::Int, _) = 1
axis_size(r::AbstractRange{Int}, _) = length(r)

function add_data_set(out::MemoryOutput, label::Symbol, spec::OutputSpec)
    h = DataHeader(data_kind(spec), spec.slice, spec.write_interval)
    out.header.data_sets[label] = h

    slice = spec.slice
    write_interval = spec.write_interval

    full_size = out.header.grid_size
    n_steps = div(out.header.time_steps, write_interval)
    n_facies = out.header.n_facies

    if h.kind == :volume
        size = axis_size.(slice, full_size)
        out.data_volumes[label] = DataVolume(
            slice, write_interval,
            zeros(Amount, n_facies, size..., n_steps),
            zeros(Amount, n_facies, size..., n_steps),
            zeros(Amount, n_facies, size..., n_steps),
            zeros(Amount, size..., n_steps + 1))
    elseif h.kind == :slice
        size = axis_size.(slice, full_size)
        slice_size = size[1] == 1 ? size[2] : size[1]
        out.data_slices[label] = DataSlice(
            slice, write_interval,
            zeros(Amount, n_facies, slice_size, n_steps),
            zeros(Amount, n_facies, slice_size, n_steps),
            zeros(Amount, n_facies, slice_size, n_steps),
            zeros(Amount, slice_size, n_steps + 1))
    elseif h.kind == :column
        out.data_columns[label] = DataColumn(
            slice, write_interval,
            zeros(Amount, n_facies, n_steps),
            zeros(Amount, n_facies, n_steps),
            zeros(Amount, n_facies, n_steps),
            zeros(Amount, n_steps + 1))
    end
end

function set_attribute(out::MemoryOutput, name::String, value::Any)
    out.header.attributes[name] = value
end

write_sediment_thickness(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,0}) =
    out.data_columns[label].sediment_thickness[idx] = data[]
write_sediment_thickness(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,1}) =
    out.data_slices[label].sediment_thickness[:, idx] .= data
write_sediment_thickness(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,2}) =
    out.data_volumes[label].sediment_thickness[:, :, idx] .= data

write_production(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,1}) =
    out.data_columns[label].production[:, idx] .+= data
write_production(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,2}) =
    out.data_slices[label].production[:, :, idx] .+= data
write_production(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,3}) =
    out.data_volumes[label].production[:, :, :, idx] .+= data

write_disintegration(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,1}) =
    out.data_columns[label].disintegration[:, idx] .+= data
write_disintegration(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,2}) =
    out.data_slices[label].disintegration[:, :, idx] .+= data
write_disintegration(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,3}) =
    out.data_volumes[label].disintegration[:, :, :, idx] .+= data

write_deposition(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,1}) =
    out.data_columns[label].deposition[:, idx] .+= data
write_deposition(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,2}) =
    out.data_slices[label].deposition[:, :, idx] .+= data
write_deposition(out::MemoryOutput, label::Symbol, idx::Int, data::AbstractArray{Amount,3}) =
    out.data_volumes[label].deposition[:, :, :, idx] .+= data

end</code></pre><h2 id="Tests"><a class="docs-heading-anchor" href="#Tests">Tests</a><a id="Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Tests" title="Permalink"></a></h2><div class="noweb-label">file:<i>test/Output/DataSpec.jl</i></div><pre><code class="language- julia hljs">module OutputDataSpec
using CarboKitten
using CarboKitten.Output.Abstract: frame_writer, add_data_set, Frame
using CarboKitten.Output.MemoryWriter: MemoryOutput
using Unitful
using Test

const DummyFacies = [
    ALCAP.Facies(
        viability_range = (0, 0),
        activation_range = (0, 0),
        maximum_growth_rate=0.0u&quot;m/Myr&quot;,
        extinction_coefficient=0.0u&quot;m^-1&quot;,
        saturation_intensity=0.0u&quot;W/m^2&quot;,
        diffusion_coefficient=0.0u&quot;m/yr&quot;)]

const input = ALCAP.Input(
    tag=&quot;test&quot;,
    box=Box{Periodic{2}}(grid_size=(5, 1), phys_scale=5.0u&quot;m&quot;),
    time=TimeProperties(
        Δt=0.0001u&quot;Myr&quot;,
        steps=10),
    output=Dict(
        :wi1 =&gt; OutputSpec(slice=(:,:), write_interval=1),
        :wi2 =&gt; OutputSpec(slice=(:,:), write_interval=2),
        :wi3 =&gt; OutputSpec(slice=(:,:), write_interval=3),
        :wi4 =&gt; OutputSpec(slice=(:,:), write_interval=4)),
    ca_interval=1,
    initial_topography=(x, y) -&gt; -0.0u&quot;m&quot;,
    sea_level = t -&gt; 0.0u&quot;m&quot;,
    subsidence_rate=0.0u&quot;m/Myr&quot;,
    disintegration_rate=0.0u&quot;m/Myr&quot;,
    insolation=0.0u&quot;W/m^2&quot;,
    sediment_buffer_size=0,
    depositional_resolution=0.0u&quot;m&quot;,
    facies=DummyFacies)

@testset &quot;OutputData&quot; begin

    out = MemoryOutput(input)
    write_frame = frame_writer(input, out)

    for (k, v) in input.output
        add_data_set(out, k, v)
    end

    # create a frame of ones to be the deposition etc. each time step
    dummy_data = ones(Float64, 1, 5, 1) * u&quot;m&quot;
    inc = Frame(
        production = dummy_data,
        deposition = dummy_data,
        disintegration = dummy_data
    )

    for t = 1:input.time.steps
        write_frame(t, inc)
    end

    @testset &quot;size of output array&quot; begin
        @test size(out.data_volumes[:wi1].deposition)[4] == 10
        @test size(out.data_volumes[:wi2].deposition)[4] == 5
        @test size(out.data_volumes[:wi3].deposition)[4] == 3
        @test size(out.data_volumes[:wi4].deposition)[4] == 2
    end

    @testset &quot;frame written only every write_interval&quot; begin
        @test all(out.data_volumes[:wi1].deposition .≈ out.data_volumes[:wi1].write_interval*1.0u&quot;m&quot;)
        @test all(out.data_volumes[:wi2].deposition .≈ out.data_volumes[:wi2].write_interval*1.0u&quot;m&quot;)
        @test all(out.data_volumes[:wi3].deposition .≈ out.data_volumes[:wi3].write_interval*1.0u&quot;m&quot;)
        @test all(out.data_volumes[:wi4].deposition .≈ out.data_volumes[:wi4].write_interval*1.0u&quot;m&quot;)
    end

end

end</code></pre><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../h5writer/">« HDF5 Output</a><a class="docs-footer-nextpage" href="../../data-export/">CSV Export »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 10:07">Thursday 4 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
