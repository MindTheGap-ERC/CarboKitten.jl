var documenterSearchIndex = {"docs":
[{"location":"unitful/#Unitful","page":"Unitful","title":"Unitful","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Physical quantities in CarboKitten are always specified using the Unitful.jl framework.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">file:<i>test/Unitful.jl</i></div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@testset \"Unitful\" begin\n    using Unitful\n    using Unitful.DefaultSymbols\n    using CarboKitten.Utility\n\n    <<unitful-spec>>\nend","category":"page"},{"location":"unitful/#Variables-vs.-string-macros","page":"Unitful","title":"Variables vs. string macros","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Unitful package offers two basic ways to enter quantities: either using predefined symbols (polluting your namespace with one-letter variables), or using special string macros.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@test 1.0m === 1.0u\"m\"\n@test 42J/s == 42u\"W\"","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"In many cases, your CarboKitten scripts will contain little else than the input specification. In such a case using Unitful.DefaultSymbols gives a bit cleaner, more readable look.","category":"page"},{"location":"unitful/#Reading-specs","page":"Unitful","title":"Reading specs","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Suppose we simulate a pendulum. We would have an input spec defined as follows:","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@kwdef struct Pendulum\n    length :: typeof(1.0m)\n    time_step :: typeof(1.0s)\n    phi0 :: typeof(1.0rad)\n    omega0 :: typeof(1.0rad/s)\nend","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Then input can be given as follows:","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"pendulum = Pendulum(\n    length = 2.0m,\n    time_step = 1ms,\n    phi0 = 30¬∞,\n    omega0 = 0rad/s\n)","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Units are automatically converted to the types specified in the API.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@test pendulum.time_step === 0.001s\n@test pendulum.phi0 === (œÄ/6)rad","category":"page"},{"location":"unitful/#Dimensions","page":"Unitful","title":"Dimensions","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Unitful has dimensions of length ùêã, mass ùêå and time ùêì as bold upper-case Unicode symbols. These can be entered in Julia with \\bfL, \\bfM etc. When you define a function that needs, say, an energy, which has SI units of rm J = (ms)^2 kg, we can construct the dimensions. Defining a few constants:","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"let ùêÑ = (ùêã/ùêì)^2 * ùêå,\n    h = 6.62607015e-34u\"J*s\",\n    c = 299792458u\"m/s\"\n    <<unitful-photon-example>>\nend","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"We can abstract over the specific units by defining a generic method. Now we can compute the wavelength of a photon, given its energy in any unit of energy.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-photon-example‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"photon_wave_length(E::Quantity{Float64,ùêÑ,J}) where {J} =\n    uconvert(u\"‚Ñ´\", h * c / E)\n\n@test photon_wave_length(2.38u\"eV\") ‚âà 5209.4201u\"‚Ñ´\"\n@test_throws MethodError photon_wave_length(1u\"m\")","category":"page"},{"location":"unitful/#Negating-Units","page":"Unitful","title":"Negating Units","text":"","category":"section"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"There is a handy way of negating units (getting back to raw scalars) using the NoUnits function object.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@test 23u\"km\" / u\"m\" |> NoUnits == 23000","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"Now, suppose we have a Vector of which we don't know the exact units, but we want to save values in meters to HDF5. When we get a vector in meters, and divide by u\"m\", Unitful will simplify and return a plain Vector{Float64}. However, if the units were u\"km\", then we need to convert by multiplying by 1000. We could do vec .|> NoUnits, but this will always allocate a new vector, even when it is not needed. We have the short-hand in_units_of that solves this issue.","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°unitful-spec‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"@test 23u\"km\" |> in_units_of(u\"m\") == 23000\n@test [4, 5, 6]u\"m\" |> in_units_of(u\"m\") == [4, 5, 6]","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"<div class=\"noweb-label\">‚™°utility‚™¢‚â£</div>","category":"page"},{"location":"unitful/","page":"Unitful","title":"Unitful","text":"function in_units_of(unit)\n    function magnitude(a::AbstractArray{Quantity{RT, NoDims, U}, dim}) where {RT <: Real, U, dim}\n        return a .|> NoUnits\n    end\n\n    function magnitude(a::AbstractArray{RT, dim}) where {RT <: Real, dim}\n        return a\n    end\n\n    function magnitude(a::RT) where {RT <: Real}\n        return a\n    end\n\n    function magnitude(a::Quantity{RT, NoDims, U}) where {RT <: Real, U}\n        return a |> NoUnits\n    end\n\n    function (x)\n        x / unit |> magnitude\n    end\nend","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<div class=\"citation canonical\"><dl><dt>[1]</dt>\n<dd>\n<div id=\"Bosscher1992\">H. Bosscher and W. Schlager. <i>Computer simulation of reef growth</i>. Sedimentology <b>39</b>, 503‚Äì512 (1992).</div>\n</dd><dt>[2]</dt>\n<dd>\n<div id=\"Burgess2013\">P. M. Burgess. <i>CarboCAT: A cellular automata model of heterogeneous carbonate strata</i>. Computers \\& geosciences <b>53</b>, 129‚Äì140 (2013).</div>\n</dd><dt>[3]</dt>\n<dd>\n<div id=\"Paola1992\">C. Paola, P. L. Heller and C. L. Angevine. <i>The large-scale dynamics of grain-size variation in alluvial basins, 1: Theory</i>. Basin research <b>4</b>, 73‚Äì90 (1992).</div>\n</dd><dt>[4]</dt>\n<dd>\n<div id=\"James2010\">S. C. James, C. A. Jones, M. D. Grace and J. D. Roberts. <i>Advances in sediment transport modelling</i>. Journal of Hydraulic Research <b>48</b>, 754‚Äì763 (2010).</div>\n</dd>\n</dl></div>","category":"page"},{"location":"bs92-w-erosion/#Bosscher-and-Schlager-model-with-erosion","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"","category":"section"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"<div class=\"noweb-label\">file:<i>src/Erosion.jl</i></div>","category":"page"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"module Erosion\n\nusing DifferentialEquations\nusing CSV\nusing DataFrames\nusing Interpolations\n\ng(g‚Çò, I‚ÇÄ, I‚Çñ, k, w) = g‚Çò * tanh(I‚ÇÄ/I‚Çñ * exp(-w * k))\n\nstruct Parameters\n     I‚ÇÄ::Float64\n     I‚Çñ::Float64\n     k::Float64\n     g‚Çò::Float64\n     <<erosion-parameters>>\nend\n\ng(p::Parameters, w) = g(p.g‚Çò, p.I‚ÇÄ, p.I‚Çñ, p.k, w)\n\nfunction model(p::Parameters, s, t_end::Float64, h‚ÇÄ::Float64)\n     ‚àÇh(h::Float64, _, t::Float64) = let w = h - s(t)\n          w >= 0.0 ? -g(p, h - s(t)) : 0.0\n     end\n     ode = ODEProblem(‚àÇh, h‚ÇÄ, (0.0, t_end), Nothing)\n     solve(ode, Euler(), dt=10.0, reltol=1e-6, saveat=1000.0)\nend\n\nfunction sealevel_curve()\n     data = DataFrame(CSV.File(\"data/bs92-sealevel-curve.csv\"))\n     linear_interpolation(data.time, data.depth)\nend\n\nstruct Scenario\n     param::Parameters\n     sealevel\n     t_end::Float64\nend\n\nmodel(s::Scenario, h‚ÇÄ::Float64) = model(s.param, s.sealevel, s.t_end, h‚ÇÄ)\n\nSCENARIO_A = Scenario(\n     Parameters(2000.0, 250.0, 0.05, 0.005, 0.007),\n     sealevel_curve(),\n     80_000.0)\n\nend","category":"page"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"function erosion(p::Parameters)\n    p.dissolution_constant\nend","category":"page"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"<div class=\"noweb-label\">‚™°erosion-parameters‚™¢‚â£</div>","category":"page"},{"location":"bs92-w-erosion/","page":"Bosscher and Schlager model with erosion","title":"Bosscher and Schlager model with erosion","text":"dissolution_constant::Float64","category":"page"},{"location":"active-layer-transport/#Active-Layer-Transport","page":"Active Layer","title":"Active Layer Transport","text":"","category":"section"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"The following is inspired on well-known active layer approaches in river bed sediment transport [3] [4] [1]. All quantities with subscript f are facies dependent. Sediment is measured in meters of deposited material. P_f is the production of sediment per facies in ms. Further unit calculations would be more readable if we consider the unit of sediment as separate, so for instance it doesn't cancel against m^2 in the units of sediment flux. In the implementation, nu has the units of rm m which is totaly weird. TBC","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"[1]: Literature on active (or mixing) layer transport modeling is vast. Most of which is concerned with much smaller time scales, and more complicated physics than we are mostly dealing with.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"In a model without transport, we could write","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"sigma + sum_f partial eta_f over partial t = sum_f P_f","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"where sigma is the subsidence rate in ms. We consider the mass balance for each facies separately.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"We suppose that loose sediment, either fresh production or disintegrated older sediment, is being transported in a layer on top of the sea bed. The flux in this layer is assumed to be directly proportional to the local slope of the sea bed  nabla_x eta_* , where eta_* = sum_f eta_f, the sum over all facies contributions, including eta_0, the initial bedrock eleveation.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"(Image: Schematic of Active Layer approach)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"The active layer now contains a concentration C_f particles of different grain size (for each facies f). If needed, C_f = alpha_f P_f where alpha_f is some facies parameter determining the fraction of production that is available for transport. The sediment flux is given as,","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"bf q_f = -nu_f C_f bf nabla_x eta_*","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"The following is the mass balance:","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"sigma + partial eta_* over partial t = -sum_f bf nabla_x cdot bf q_f + sum_f P_f","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"In our modelling we keep track of individual contributions per facies over time [2].","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"[2]: Note that in other approaches to active layer transport, like Paola 1992, there would be a factor 1C_f. Here we have a different interpretation to what the concentration means: the sediment settles down after transport, such that the concentration has no impact on the change in sediment surface elevation.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Combining these equations, and ignoring subsidence for the moment (which is a global effect and can't be expressed on a per-facies basis), we get a component-wise diffusion equation","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"partial eta_f(x)overpartial t = bf nabla_x cdot big nu_f alpha_f P_f(x) bf nabla_x eta_*(x) big + P_f(x)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"In our model we need to solve this equation one time-step each iteration. If we solve this using forward methods, we should be reminded of the CFL limit for diffusion equations (depending on the diffusion constants and grid size we shouldn't pick the time steps too large). Alternatively, for these two-dimensional situations, an implicit approach is feasible. Also we should take care that somehow nabla(nualpha P nabla eta) + P  0. The interpretation being that we can't transport more than we produce, even if there is capacity to do so.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"To solve this equation, it is nicer to expand the transport-diffusion term using the product rule, in short notation:","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"partial_t eta_f = nu nabla P_f(x) cdot nabla eta(x) + nu P_f(x) nabla^2 eta(x) + P_f(x)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"where nu = nu_f alpha_f","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"So we have a advection component with velocity nu nabla P_f and a diffusion component with a coefficient nu P_f.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"As part of the production P_f we disintegrate older sediment at a fixed rate.","category":"page"},{"location":"active-layer-transport/#Test-1:-production-transport","page":"Active Layer","title":"Test 1: production transport","text":"","category":"section"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Suppose we have an incline in one direction, as per usual on a coastal slice. Production is happening in a circular patch in our box, with constant rate. In addition, we'll release the top 1m of sediment for further transport.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<details><summary>Test model</summary>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">file:<i>examples/transport/active-layer.jl</i></div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"module ActiveLayer\n\nusing Unitful\nusing CarboKitten.Stencil: convolution, stencil\nusing CarboKitten.Config: Box, axes\nusing CarboKitten.BoundaryTrait: Shelf\nusing CarboKitten.Utility: in_units_of\nusing CarboKitten.Transport.ActiveLayer: pde_stencil, Amount, Rate\n\n<<example-active-layer>>\n\nend","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"</details>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Our input structure facilitates a single facies, specifying an initial bedrock elevation, sediment layer and a function for a location dependent constant production rate. The transport is parametrized by a disintegration rate and a diffusion coefficient.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">‚™°example-active-layer‚™¢‚â£</div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"@kwdef struct Input\n\tbox\n\tŒît::typeof(1.0u\"Myr\")\n\tt_end::typeof(1.0u\"Myr\")\n\tbedrock_elevation   # function (x::u\"m\", y::u\"m\") -> u\"m\"\n\tinitial_sediment    # function (x::u\"m\", y::u\"m\") -> u\"m\"\n\tproduction          # function (x::u\"m\", y::u\"m\") -> u\"m/s\"\n\tdisintegration_rate::typeof(1.0u\"m/Myr\")\n\tsubsidence_rate::typeof(1.0u\"m/Myr\")\n\tdiffusion_coefficient::typeof(1.0u\"m\")\nend","category":"page"},{"location":"active-layer-transport/#Production-patch","page":"Active Layer","title":"Production patch","text":"","category":"section"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Establish a grid of 100x50, 15km on each side, dropping from 0 to 50m depth. Keeping the disintegration rate to a similar value as the production rate seems a sensible choice.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">‚™°example-active-layer‚™¢‚â£</div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"production_patch(center, radius, rate) = function(x, y)\n\t(pcx, pcy) = center\n\t(x - pcx)^2 + (y - pcy)^2 < radius^2 ?\n\t\trate :\n\t\t0.0u\"m/Myr\"\nend\n\nconst input = Input(\n\tbox=Box{Shelf}(grid_size=(100, 50), phys_scale=150.0u\"m\"),\n\tŒît=0.001u\"Myr\",\n\tt_end=1.0u\"Myr\",\n\n\tbedrock_elevation = (x, y) -> -x / 300.0,\n\tinitial_sediment = (x, y) -> 0.0u\"m\",\n\n\tproduction = production_patch(\n\t\t(5000.0u\"m\", 3750.0u\"m\"),\n\t\t2.0u\"km\",\n\t\t50.0u\"m/Myr\"),\n\n\tdisintegration_rate = 50.0u\"m/Myr\",\n\tsubsidence_rate = 50.0u\"m/Myr\",\n\n\tdiffusion_coefficient = 10000.0u\"m\"\n)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"(Image: Production patch on an inclining bedrock)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">file:<i>examples/transport/active-layer-plot-production.jl</i></div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"#| requires: examples/transport/active-layer.jl\n#| creates: docs/src/_fig/active-layer-production-patch.png\n#| collect: figures\n\ninclude(\"active-layer.jl\")\nusing Unitful\nusing CarboKitten.Config: axes\nusing CarboKitten.Utility: in_units_of\nusing CairoMakie\nusing .ActiveLayer: input\n\nfunction main()\n  (x, y) = axes(input.box)\n  Œ∑ = input.bedrock_elevation.(x, y')\n  p = input.production.(x, y')\n\n  fig = Figure()\n  ax = Axis3(fig[1,1], xlabel=\"x (km)\", ylabel=\"y (km)\", zlabel=\"Œ∑ (m)\", azimuth=5œÄ/3)\n  surface!(ax, x |> in_units_of(u\"km\"), y |> in_units_of(u\"km\"), Œ∑ |> in_units_of(u\"m\"), color = p |> in_units_of(u\"m/Myr\"))\n  save(\"docs/src/_fig/active-layer-production-patch.png\", fig)\nend\n\nmain()","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"</details>","category":"page"},{"location":"active-layer-transport/#Solving-the-PDE","page":"Active Layer","title":"Solving the PDE","text":"","category":"section"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Just as a reminder:","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"partial_t eta_f = nu nabla P_f(x) cdot nabla eta(x) + nu P_f(x) nabla^2 eta(x) + P_f(x)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Below is the kernel encoding a central differencing scheme i.e. [-1, 0, 1]/(2Œîx) for first derivative and [0 -1 0; -1 4 -1; 0 -1 0]/Œîx^2 for the laplacian.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">file:<i>src/Transport/ActiveLayer.jl</i></div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"module ActiveLayer\n\nusing Unitful\nusing ...BoundaryTrait\nusing ...Config: Box\nusing ...Stencil: stencil\n\nconst Rate = typeof(1.0u\"m/Myr\")\nconst Amount = typeof(1.0u\"m\")\n\nfunction pde_stencil(box::Box{BT}, ŒΩ) where {BT <: Boundary{2}}\n\tŒîx = box.phys_scale\n\n\tfunction kernel(x)\n\t\tadv = ŒΩ * ((x[3, 2][1] - x[1, 2][1]) * (x[3, 2][2] - x[1, 2][2]) +\n     \t\t\t   (x[2, 3][1] - x[2, 1][1]) * (x[2, 3][2] - x[2, 1][2])) /\n\t\t\t      (2Œîx)^2\n\n\t\tdif = ŒΩ * x[2, 2][2] * (x[3, 2][1] + x[2, 3][1] + x[1, 2][1] +\n\t\t\t\t  x[2, 1][1] - 4*x[2, 2][1]) / (Œîx)^2\n\n\t\tprd = x[2, 2][2]\n\n\t\treturn max(0.0u\"m\", adv + dif + prd)\n\tend\n\n\tstencil(Tuple{Amount, Amount}, Amount, BT, (3, 3), kernel)\nend\n\nend","category":"page"},{"location":"active-layer-transport/#Model-loop","page":"Active Layer","title":"Model loop","text":"","category":"section"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Every iteration we determine the maximum disintegrated sediment. If the total amount of sediment is smaller than the maximum, then that amount is disintegrated instead. We compute the concentrations in the active layer in terms of amounts of sediment, so P Delta t. Since P appears in every term of the PDE, we're free to do so.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">‚™°example-active-layer‚™¢‚â£</div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"mutable struct State\n\ttime::typeof(1.0u\"Myr\")\n\tsediment::Matrix{typeof(1.0u\"m\")}\nend\n\nfunction initial_state(input)\n    x, y = axes(input.box)\n\tState(0.0u\"Myr\", input.initial_sediment.(x, y'))\nend\n\nstruct Frame\n\tt::typeof(1.0u\"Myr\")\n\tŒ¥::Matrix{Amount}\nend\n\nfunction propagator(input)\n\tŒ¥ = Matrix{Amount}(undef, input.box.grid_size...)\n\tx, y = axes(input.box)\n\tŒº0 = input.bedrock_elevation.(x, y')\n\n\tfunction active_layer(state)\n\t\tmax_amount = input.disintegration_rate * input.Œît\n\t\tamount = min.(max_amount, state.sediment)\n\t\tstate.sediment .-= amount\n\n\t\tinput.production.(x, y') * input.Œît .+ amount\n\tend\n\n\tstc = pde_stencil(input.box, input.diffusion_coefficient)\n\tapply_pde(Œº::Matrix{Amount}, p::Matrix{Amount}) = stc(tuple.(Œº, p), Œ¥)\n\n\tfunction (state)\n\t\tp = active_layer(state)\n\t\tapply_pde(state.sediment .+ Œº0, p)\n\t\treturn Frame(state.time, Œ¥)\n\tend\nend\n\nfunction run_model(input)\n\tstate = initial_state(input)\n\tprop = propagator(input)\n\n\tChannel{State}() do ch\n\t\twhile state.time < input.t_end\n\t\t\tŒî = prop(state)\n\t\t\tstate.sediment .+= Œî.Œ¥\n\t\t\tstate.time += input.Œît\n\t\t\tput!(ch, state)\n\t\tend\n\tend\nend","category":"page"},{"location":"active-layer-transport/#Running-the-model","page":"Active Layer","title":"Running the model","text":"","category":"section"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"We run the model with 1000 time steps but only inspect one in every 100.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"(Image: Active layer test)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">file:<i>examples/transport/active-layer-plot-result.jl</i></div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"#| requires: examples/transport/active-layer.jl\n#| creates: docs/src/_fig/active-layer-test.png\n#| collect: figures\n\ninclude(\"active-layer.jl\")\nusing CairoMakie\nusing Unitful\nusing CarboKitten.Config: axes\nusing CarboKitten.Utility: in_units_of\nusing .ActiveLayer: input, run_model\n\nfunction main()\n  result = Iterators.map(deepcopy,\n  \tIterators.filter(x -> mod(x[1], 100) == 0, enumerate(run_model(input)))) |> collect\n\n\t(x, y) = axes(input.box)\n\tŒ∑ = input.bedrock_elevation.(x, y') .+ result[10][2].sediment .- input.subsidence_rate * result[10][2].time\n\t# p = input.production.(x, y')\n\n\tfig = Figure(size=(800, 1000))\n\tax = Axis3(fig[1:2,1], xlabel=\"x (km)\", ylabel=\"y (km)\", zlabel=\"Œ∑ (m)\", azimuth=5œÄ/3)\n\tsurface!(ax, x |> in_units_of(u\"km\"), y |> in_units_of(u\"km\"), Œ∑ |> in_units_of(u\"m\"))\n\n\tax2 = Axis(fig[3,1], xlabel=\"x (km)\", ylabel=\"Œ∑ (m)\")\n\n\tfor i in 1:10\n\t\tŒ∑ = input.bedrock_elevation.(x, y') .+ result[i][2].sediment .- input.subsidence_rate * result[i][2].time\n\n\t\tlines!(ax2, x |> in_units_of(u\"km\"), Œ∑[:, 25] |> in_units_of(u\"m\"))\n\tend\n\n\tsave(\"docs/src/_fig/active-layer-test.png\", fig)\nend\n\nmain()","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"</details>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Note in the bottom figure, due to sedimentation not keeping up with subsidence, the lines go down in time. We see the sediment transport being favoured to downslope areas, which is what we want. This effect could be made more extreme by increasing the disintegration rate.","category":"page"},{"location":"active-layer-transport/#Test-2:-erosion","page":"Active Layer","title":"Test 2: erosion","text":"","category":"section"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Suppose now we have no production, but we start with a steep gradient in the existing sediment. We expect this gradient to erode.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"In the input we set the production to zero, but we specify an initial sediment that contains both a step and a top-hat function. Erodability of these kind of features could be a measurable quantity to which we could potentially calibrate this transport model.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"Note that, due to the way we populate the active layer, the gradient nabla P will vanish, leaving us with a pure diffusion system.","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">‚™°example-active-layer-erosion‚™¢‚â£</div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"function initial_sediment(x, y)\n  if x < 5.0u\"km\"\n    return 30.0u\"m\"\n  end\n\n  if x > 10.0u\"km\" && x < 11.0u\"km\"\n    return 20.0u\"m\"\n  end\n\n  return 5.0u\"m\"\nend\n\nconst INPUT = ActiveLayer.Input(\n\tbox                   = Box{Shelf}(grid_size=(100, 1), phys_scale=150.0u\"m\"),\n\tŒît                    = 0.001u\"Myr\",\n\tt_end                 = 1.0u\"Myr\",\n\n\tbedrock_elevation     = (x, y) -> -30.0u\"m\",\n\tinitial_sediment      = initial_sediment,\n\tproduction            = (x, y) -> 0.0u\"m/Myr\",\n\n\tdisintegration_rate   = 50.0u\"m/Myr\",\n\tsubsidence_rate       = 50.0u\"m/Myr\",\n\tdiffusion_coefficient = 10000.0u\"m\")","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"(Image: Active layer erosion test)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"<div class=\"noweb-label\">file:<i>examples/transport/active-layer-erosion.jl</i></div>","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"#| requires: examples/transport/active-layer.jl\n#| creates: docs/src/_fig/active-layer-erosion.png\n#| collect: figures\n\nmodule ActiveLayerErosion\n\ninclude(\"active-layer.jl\")\n\nusing Unitful\nusing CarboKitten.BoundaryTrait: Shelf\nusing CarboKitten.Config: Box, axes\nusing CarboKitten.Utility: in_units_of\nusing CairoMakie\n\n<<example-active-layer-erosion>>\n\nfunction main(input)\n    y_idx = 1\n    result = Iterators.map(deepcopy,\n  \t    Iterators.filter(x -> mod(x[1]-1, 400) == 0, enumerate(ActiveLayer.run_model(input)))) |> collect\n\n\t(x, y) = axes(input.box)\n\t# p = input.production.(x, y')\n\n\tfig = Figure(size=(800, 600))\n\t# ax = Axis3(fig[1:2,1], xlabel=\"x (km)\", ylabel=\"y (km)\", zlabel=\"Œ∑ (m)\", azimuth=5œÄ/3)\n\t# surface!(ax, x |> in_units_of(u\"km\"), y |> in_units_of(u\"km\"), Œ∑ |> in_units_of(u\"m\"))\n\n\tax2 = Axis(fig[1,1], xlabel=\"x (km)\", ylabel=\"Œ∑ (m)\")\n\n\tfor r in result\n\t\tŒ∑ = input.bedrock_elevation.(x, y') .+ r[2].sediment .- input.subsidence_rate * r[2].time\n\n\t\tlines!(ax2, x |> in_units_of(u\"km\"), Œ∑[:, y_idx] |> in_units_of(u\"m\"))\n\tend\n\n\tsave(\"docs/src/_fig/active-layer-erosion.png\", fig)\nend\n\nend\n\nActiveLayerErosion.main(ActiveLayerErosion.INPUT)","category":"page"},{"location":"active-layer-transport/","page":"Active Layer","title":"Active Layer","text":"</details>","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"title: CarboKitten subtitle: Sediment Transport ‚Äì-","category":"page"},{"location":"carbocat-transport/#Transport","page":"Sediment Transport","title":"Transport","text":"","category":"section"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"The sediment that is produced is distributed into lower lying neighbour cells that are not occupied by a producer. A user defined fraction of sediment from a producer is transported, first divided equally to lower neighbours, cascading to its neighbours by splitting in half and so on. The cascade stops when the sediment reaches a minimal threshold.","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"Thus, this step has two free parameters: the transported fraction of produced carbonate and the lower threshold.","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"Apparent from the illustration in B13 Figure 4, a 8-cell neighbourhood is used. Nothing is mentioned about the order in which the transport is computed. We may tag transported sediment with a bit flip and assign a new lythofacies to transported sediment.","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"<div class=\"noweb-label\">‚™°ck-types‚™¢‚â£</div>","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"struct Deposit{N}\n    amount::NTuple{N, Float64}\nend\n\nBase.zero(::Type{Deposit{N}}) where {N} =\n    Deposit{N}(ntuple(_ -> zero(Float64), N))","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013/Transport.jl</i></div>","category":"page"},{"location":"carbocat-transport/","page":"Sediment Transport","title":"Sediment Transport","text":"module Transport\n\nusing ...BoundaryTrait\nusing ...Stencil\nusing Transducers\n\nstruct Product\n    species::Int\n    amount::Float64\nend\n\nBase.zero(::Type{Product}) = Product(0, 0.0)\n\nstruct Deposit{N}\n    amount::NTuple{N, Float64}\nend\n\nBase.zero(::Type{Deposit{N}}) where {N} =\n    Deposit{N}(ntuple(_ -> zero(Float64), N))\n\nfunction deposit(\n        ::Type{B},\n        production::Matrix{Product},\n        elevation::Matrix{Float64},\n        transported::Matrix{Deposit{N}},\n        lim::Float64,\n        idx::CartesianIndex,\n        p::Product\n    ) where {B <: Boundary{2}, N}\n\n    if p.amount <= lim\n        transported[idx][p.species] += p.amount\n        return\n    end\n\n    shape = size(production)\n    targets = CartesianIndices((-1:1,-1:1)) |>\n        Filter(Œîi -> Œîi!=CartesianIndex(0,0)) |>\n        Map(Œîi -> offset_index(B, shape, idx, Œîi)) |>\n        Filter(j -> !isnothing(j) &&\n                    elevation[j] >= elevation[idx] &&\n                    production[j].species == 0) |>\n        collect\n\n    if isempty(targets)\n        transported[idx][p.species] += p.amount\n        return\n    end\n    transported[idx][p.species] += p.amount / 2\n    for j in targets\n        q = Product(p.species, p.amount / (2 * length(targets)))\n        deposit(B, production, elevation, transported, lim, j, q)\n    end\nend\n\nfunction transport(\n        ::Type{B},\n        n_species::Int,\n        production::Matrix{Product},\n        elevation::Matrix{Float64},\n        fraction::Float64,\n        lim::Float64\n    ) where {B <: Boundary{2}}\n\n    shape = size(production)\n    result = zeros(Transported{n_species})\n\n    for i in CartesianIndices(shape)\n        production[i].amount <= lim && continue\n        p = copy(production[i])\n        p.amount *= fraction\n        production[i].amount -= p.amount\n        deposit(B, production, elevation, result, lim, i, p)\n    end\n\n    return result\nend\n\nend","category":"page"},{"location":"carbocat/#About","page":"Summary","title":"About","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"CarboCAT is primarily based on a very simple cellular automaton (CA). We may explore this CA as a first step in implementing the model in Julia.","category":"page"},{"location":"carbocat/#Overview","page":"Summary","title":"Overview","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"The CarboCAT model [2] consists of several components, many of which are optional or contain optional levels of complexity.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Species habitation: an algorithm is in place to evolve the locality of a number of factory species.\nSediment production: each species will produce sediment according to some model.\nTransport: sediment may be transported from a production site to elsewhere due to gravity, waves or other types of mixing.\nErosion: sediment may erode depending on local circumstances or sediment type.\nCompactification: different types of sediment may respond to compression forces differently.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"These processes describe the intrinsic properties of the model. Any parameters that change these processes will be referred to as model parameters. Next to that, there are some extrinsic parameters that change the specific output of a model: the initial depth of the sea bed (also known as bathymetry) and variation in sea level (including subsidence). These we call input parameters.","category":"page"},{"location":"carbocat/#Carbonate-production","page":"Summary","title":"Carbonate production","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"By itself, a sediment production model is enough to model a cross-section of a carbonate platform [BS92: @Bosscher1992]. As a first step, we have reproduced some results of BS92. Using a reasonably simple approximation of a growth rate as","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"[partial_t h = - g_m tanh leftfracI_0I_k exp(-k * (h - s(t))right]{#eq:growth-rate-eqn}","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"where h is the depth of the sea floor, g_m is the maximum growth rate, I_0 the surface light intensity, I_k the saturating light intensity, k the extinction coefficient, and s the (extrinsic) sea-level. In one example given by BS92, we arrived at the following profile.","category":"page"},{"location":"carbocat/#Species-habitation","page":"Summary","title":"Species habitation","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"These species can be anything, just remember that they are the progenitor of some (limestone) facies type. In the original 2013 model, this stage is implemented by a celullar automaton (or CA). The CA has the nice property of giving pseudo-random output with at least some degree of coherence. There is no physical basis to the CA model, but neither is there very much data to test a physical model against.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"We have implemented the CA used in Burgess 2013. Using three species with identical 4-6-10-10 rules (survival between 4 to 10 neighbours, birth between 6-10 live neighbours).","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"(Image: )","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"An interesting question is under what rules is this CA stable (i.e. keeps evolving)?","category":"page"},{"location":"carbocat/#Combination","page":"Summary","title":"Combination","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"The minimal Carbocat model would consist of only species habitation and production.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":":::details","category":"page"},{"location":"carbocat/#Some-submodules","page":"Summary","title":"Some submodules","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013.jl</i></div>","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"module Burgess2013\n\ninclude(\"Burgess2013/Config.jl\")\ninclude(\"Burgess2013/CA.jl\")\ninclude(\"Burgess2013/Production.jl\")\ninclude(\"Burgess2013/Transport.jl\")\n\nusing .CA\nusing .Config\nusing .Production\n\nexport production_rate, run_ca, Facies, MODEL1\n\nend","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"noweb-label\">‚™°ck-types‚™¢‚â£</div>","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"export Product\n\nstruct Product\n    species::Int\n    amount::Float64\nend\n\nBase.zero(::Type{Product}) = Product(0, 0.0)","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013/Config.jl</i></div>","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"module Config\n\nusing Unitful\nexport Facies, MODEL1\n\n@kwdef struct Facies\n    viability_range::Tuple{Int, Int}\n    activation_range::Tuple{Int, Int}\n\n    maximum_growth_rate::typeof(1.0u\"m/Myr\")\n    extinction_coefficient::typeof(1.0u\"m^-1\")\n    saturation_intensity::typeof(1.0u\"W/m^2\")\nend\n\nconst MODEL1 = [\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 500u\"m/Myr\",\n           extinction_coefficient = 0.8u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\"),\n\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 400u\"m/Myr\",\n           extinction_coefficient = 0.1u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\"),\n\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 100u\"m/Myr\",\n           extinction_coefficient = 0.005u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\")\n]\n\nend","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":":::","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013/Production.jl</i></div>","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"module Production\n\nexport production_rate\n\nusing Unitful\nusing ..Config: Facies\n\n<<carbonate-production>>\n\nfunction production_rate(insolation, facies, water_depth)\n    g‚Çò = facies.maximum_growth_rate\n    I = insolation / facies.saturation_intensity\n    x = water_depth * facies.extinction_coefficient\n    return water_depth > 0.0u\"m\" ? g‚Çò * tanh(I * exp(-x)) : 0.0u\"m/Myr\"\nend\n\nend","category":"page"},{"location":"carbocat/#Crowding","page":"Summary","title":"Crowding","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"In crowded areas carbonate production rates are reduced. For cells where","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"n_min le n le n_opt","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"and","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"n_opt le n le n_max","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"(n_min and n_max for living cells are 4 and 10)","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"we have a linear increase and linear decrease of production rate (i.e. a triangle function).","category":"page"},{"location":"carbocat/#Subsidence","page":"Summary","title":"Subsidence","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Subsidence refers to gradual lowering or lifting of the underlying floor bed. This could be either sea level rise due to climate change, but also tectonic activity. Sea level also changes according to a given recipe with say three sinusoidals (e.g. Milankovich cycles). When a cell gets \"subaerial exposure\", i.e. the water level drops below the cell elevation (stupid jargon), accumulation stops and the cell becomes dormant. On reflooding, the cell resumes activity. From the text it is not entirely clear, but I think deactivated cells don't take part in the CA, so they count as dead neighbours.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"reference on accommodation, also links to a model called SedFlux.","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"T + E = S + W","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Saying Tectonic subsidence plus Eustatic sea-level change equals Sedimentation plus change in Water depth.","category":"page"},{"location":"carbocat/#Steps","page":"Summary","title":"Steps","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Update waterdepth, given subsidence\nUpdate sea level elevation, given eustatics\nRun CA\nCompute thickness of carbonate production\nCompute sediment transport","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"We need to keep a state with the following components:","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"height map\nspecies\nglobal time, implying:\nsea level and subsidence","category":"page"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"Every cycle we may export a layer of sediment to archive.","category":"page"},{"location":"carbocat/#References","page":"Summary","title":"References","text":"","category":"section"},{"location":"carbocat/","page":"Summary","title":"Summary","text":"<div class=\"citation canonical\"><dl>\n</dl></div>","category":"page"},{"location":"bosscher-1992/#Carbonate-Production","page":"Bosscher and Schlager 1992","title":"Carbonate Production","text":"","category":"section"},{"location":"bosscher-1992/#reproducing-Bosscher-and-Schlager-1992","page":"Bosscher and Schlager 1992","title":"reproducing Bosscher & Schlager 1992","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The paper by [1] is an early computer model for simulating reef growth. This paper contains some of the essential ingredients that we find back in CarboCAT. Here we will try to reproduce their results.","category":"page"},{"location":"bosscher-1992/#Parameters","page":"Bosscher and Schlager 1992","title":"Parameters","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Maximum growth rate G_m. The maximum rate of reef growth is in the range of 10-15 rm mm yr^-1 (Macintyre etal., 1977; Adey, 1978; Davies, 1983).\nExtinction coefficient k. This is a measure of the extinction of photosynthetically active radiation (PAR), i.e. light with a wavelength of 400-700 nm.  The value of k for oceanic waters ranges from 004 to 016 rm m^-1 (Jerlov, 1976); reported values for reef waters also lie within this range (Brakel, 1979; Van den Hoek et al., 1975; Weinberg, 1976; Chalker, 1981; Porter, 1985).\nSurface light intensity I_0. The light intensity at the water surface at midday in the tropics lies in the range of 2000-2250 rm mu E m^-2s^-1.\nSaturating light intensity I_k. Light saturating intensities are in the range 50-450 rm mu E m^-2s^-1, depending on species and water depth (Chalker, 1981; Wyman et al., 1987). Photoadaptation of reef-building corals has not been taken into account. More generally, light does not become a limiting factor for coral growth until it reaches roughly 10% of its surface value (B. E. Chalker, in Done, 1983).","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"from BS92","category":"page"},{"location":"bosscher-1992/#Growth-Rate","page":"Bosscher and Schlager 1992","title":"Growth Rate","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The growth rate is","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"g(w) = g_m tanhleft(I_0 e^-kw over I_kright)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">‚™°carbonate-production‚™¢‚â£</div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"g(g‚Çò, I‚ÇÄ, I‚Çñ, k, w) = g‚Çò * tanh(I‚ÇÄ/I‚Çñ * exp(-w * k))","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">‚™°b92-model‚™¢‚â£</div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<<carbonate-production>>\n\nstruct Parameters\n     I‚ÇÄ::Float64\n     I‚Çñ::Float64\n     k::Float64\n     g‚Çò::Float64\nend\n\ng(p::Parameters, w) = g(p.g‚Çò, p.I‚ÇÄ, p.I‚Çñ, p.k, w)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"where w is the water depth in meters, g_m is the maximum growth rate in rm m rm My^-1, I_0 is surface light intensity, I_k is saturation light intensity, and k is the extinction coefficient. We have exponential decay of light intensity as we get to deeper water, and the carbonate factories respond to light intensity through a tanh (hyperbolic tangent function). This is by no means an exact relation, rather the tanh function interpolates smoothly between one and zero. We specify a maximum growth rate and a typical intensity at which the species is no longer productive.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The shape of tanh circ exp look like this:","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"(Image: Tangens hyperbolicus)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Notice that the numbers inside the exponential need to be unit-free, so does the output. The value of tanh circ exp at a depth of 0 is 07615dots. This does not make much sense, as I believe we should start at a value of 1 at the surface. By setting I_0  I_k to some value 1 this can be alleviated, but it changes the interpretation of the constants a little. The idea is that above a certain insolation, light is not the limiting factor to the rate of photosynthesis.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"To reproduce Figure 2 in B13, I had to change the values for g_m to 500, 250, and 125 respectively, the other values from Table 2 remained the same. I guess this was done for illustration purposes.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"(Image: Production curves)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/plot-tanh.gnuplot</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"set term svg size 700, 300 font \"sans serif, 14\" linewidth 1.5\nset xrange [-5:10]\nset yrange [-0.1:1.1]\nset grid\nset key outside\nset xlabel \"x\"\nset ylabel \"y\"\nplot tanh(exp(-x)) lc rgb 'black', tanh(exp(4)*exp(-x)), tanh(exp(-0.5*x))","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/burgess2013-fig2.gnuplot</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"set term svg size 500, 600 font \"sans serif,14\" linewidth 1.5\nset trange [0:100]\nset yrange [100:0]\nset xrange [-20:520]\nset parametric\nset key right bottom\nset grid\nset ylabel \"Water depth (m)\"\nset xlabel \"Production rates\"\nplot 500*tanh(6.7 * exp(-0.8 * t)), t title 'Carbonate factory 1', \\\n     250*tanh(6.7 * exp(-0.1 * t)), t title 'Carbonate factory 2', \\\n     125*tanh(6.7 * exp(-0.005 * t)), t title 'Carbonate factory 3'","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"</details>","category":"page"},{"location":"bosscher-1992/#Depth-Evolution","page":"Bosscher and Schlager 1992","title":"Depth Evolution","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The use of water depth in both BS92 and B13 can be a bit confusing. Plots are shown up-side-down and little is done to disambiguate depth with sea level rising or lowering, or sediment accreting. Growth in deposition should give shallower sea bed. BS92 write w = (h_0 + h(t)) - (s_0 + s(t)). Actually s_0 is best set to 0, or simply included into s(t) and h_0 can be replaced with setting h(t=0) = h_0. Then, as we have the growth rate as a function of water depth g(w), we can say","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"[partial_t h = -g_m rm tanhleftfracI_0I_k exp(-k (h - s(t)))right]{#eq:growth-eqn}","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">‚™°b92-model‚™¢‚â£</div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"function model(p::Parameters, s, t_end::Float64, h‚ÇÄ::Float64)\n     ‚àÇh(h::Float64, _, t::Float64) = let w = h - s(t)\n          w >= 0.0 ? -g(p, h - s(t)) : 0.0\n     end\n     ode = ODEProblem(‚àÇh, h‚ÇÄ, (0.0, t_end), Nothing)\n     solve(ode, Euler(), dt=10.0, reltol=1e-6, saveat=1000.0)\nend","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"It seems Eq. 5 in BS92 (the most important equation in the paper mind you!) is missing both a minus sign and a set of parentheses. Also, we should remark that at negative depth (subareal exposure) we should halt all growth.","category":"page"},{"location":"bosscher-1992/#Crosssection","page":"Bosscher and Schlager 1992","title":"Crosssection","text":"","category":"section"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"The most impressive result in BS92 is the last figure. They show an input curve for s(t) but give no functional description. The curve starts with a linear drop from 0 to 120m depth over a time of 20000 years, then slowly rises with s(t) = a +  bt + A sin(2pi t  P), with a period P = sim 15-20 rm kyr, amplitude A = sim 40 rm m. It might be easiest to take a screenshot of the PDF and convert the graph into a table.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<details><summary>Extracting Sealevel Curve from an image</summary>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/BS92/fig8-sealevel.jl</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"#| creates: data/bs92-sealevel-curve.csv\n#| requires: data/bs92-sealevel-input.png\n\nmodule Script\n    using Images\n    using DataFrames\n    using CSV\n\n    function main()\n        img = load(\"data/bs92-sealevel-input.png\")\n        img_gray = Gray.(img)\n        signal = 1.0 .- channelview(img_gray)\n        signal ./= sum(signal; dims=[1])\n        (n_y, n_x) = size(signal)\n        y = sum(signal .* (1:n_y); dims=[1]) / n_y * 200.0\n        df = DataFrame(\n            time = LinRange(0.0, 80_000.0, n_x),\n            depth = y[1, :])\n        CSV.write(\"data/bs92-sealevel-curve.csv\", df)\n    end\nend\n\nScript.main()","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"</details>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Using DifferentialEquations.jl we can integrate Equation @eq:growth-eqn. Interestingly, the only integrator that gave me noise free results is Euler. This may be due to the sudden shut-down of production at w = 0.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/BS92/BS92.jl</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"module BS92\n\nusing DifferentialEquations\nusing CSV\nusing DataFrames\nusing Interpolations\n\n<<b92-model>>\n\nfunction sealevel_curve()\n     data = DataFrame(CSV.File(\"data/bs92-sealevel-curve.csv\"))\n     linear_interpolation(data.time, data.depth)\nend\n\nstruct Scenario\n     param::Parameters\n     sealevel\n     t_end::Float64\nend\n\nmodel(s::Scenario, h‚ÇÄ::Float64) = model(s.param, s.sealevel, s.t_end, h‚ÇÄ)\n\nSCENARIO_A = Scenario(\n     Parameters(2000.0, 250.0, 0.05, 0.005),\n     sealevel_curve(),\n     80_000.0)\n\nend","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Finally, we can try to reproduce figure 8 in BS92.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"(Image: stratigraphy following fig. 8 in BS92)","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"Note the simplicity of this result: there is no dependency on space, only on the initial depth h_0.","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"<div class=\"noweb-label\">file:<i>examples/BS92/fig8.jl</i></div>","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"#| creates: docs/src/_fig/bs92-fig8.svg\n#| requires: data/bs92-sealevel-curve.csv examples/BS92/BS92.jl\n#| collect: figures\n\nmodule Script\n     include(\"BS92.jl\")\n     using CairoMakie\n\n     function main()\n          h0 = LinRange(0, 200, 101)\n          result = hcat([BS92.model(BS92.SCENARIO_A, h).u for h in h0]...)\n          t = LinRange(0, 80_000, 81)\n\n          fig = Figure(resolution=(600,900))\n          ax = Axis(fig[1,1], xlabel=\"initial depth (m)\", ylabel=\"depth (m)\", yreversed=true)\n          for l in eachrow(result)\n               lines!(ax, h0, vec(l); color=:steelblue4, linewidth=0.5)\n          end\n          ax = Axis(fig[2,1], xlabel=\"time (years)\", ylabel=\"depth (m)\", yreversed=true)\n          lines!(ax, t, BS92.SCENARIO_A.sealevel(t); color=:steelblue4)\n\n          save(\"docs/src/_fig/bs92-fig8.svg\", fig)\n     end\nend\n\nScript.main()","category":"page"},{"location":"bosscher-1992/","page":"Bosscher and Schlager 1992","title":"Bosscher and Schlager 1992","text":"</details>","category":"page"},{"location":"model-alcap/#Model-with-CA,-Production-and-Active-Layer-transport-(ALCAPS)","page":"ALCAPS","title":"Model with CA, Production and Active Layer transport (ALCAPS)","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"The following Sedimentation model includes the Burgess 2013 Cellular Automaton, Bosscher & Schlager 1992 Production curves and an Active Layer transport model, based on Paola 1992, henceforth ALCAPS.","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"(Image: Result of default ALCAPS run)","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<details><summary>Default ALCAPS code</summary>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">file:<i>examples/alcaps/defaults.jl</i></div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"#| requires: src/Model/ALCAPS.jl\n#| creates: data/alcaps_default.h5\n\nusing CarboKitten.Model.ALCAPS\n\nALCAPS.main(ALCAPS.Input(), \"data/alcaps_default.h5\")","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">file:<i>examples/alcaps/plot-defaults.jl</i></div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"#| requires: ext/VisualizationExt.jl data/alcaps_default.h5\n#| creates: docs/src/_fig/alcaps_default_profile.png\n#| collect: figures\n\nusing CairoMakie\nusing Statistics\nusing GeometryBasics\nusing CarboKitten.Visualization\n\nfunction main()\n  fig = Visualization.sediment_profile(\"data/alcaps_default.h5\", 25)\n  save(\"docs/src/_fig/alcaps_default_profile.png\", fig)\nend\n\nmain()","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"</details>","category":"page"},{"location":"model-alcap/#Example-Input","page":"ALCAPS","title":"Example Input","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"The following is a complete example input.","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">file:<i>examples/alcaps/alternative.jl</i></div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"#| requires: src/Model/ALCAPS.jl\n#| creates: data/alcaps2.h5\n\nusing Unitful\nusing CarboKitten.BoundaryTrait: Shelf\nusing CarboKitten.Config: Box, TimeProperties\nusing CarboKitten.Model.ALCAPS: Facies, Input, main\n\nconst m = u\"m\"\nconst Myr = u\"Myr\"\n\nconst FACIES = [\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 500u\"m/Myr\",\n           extinction_coefficient = 0.8u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\",\n           diffusion_coefficient = 10000u\"m\"),\n\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 400u\"m/Myr\",\n           extinction_coefficient = 0.1u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\",\n           diffusion_coefficient = 5000u\"m\"),\n\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 100u\"m/Myr\",\n           extinction_coefficient = 0.005u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\",\n           diffusion_coefficient = 7000u\"m\")\n]\n\nconst PERIOD = 0.2Myr\nconst AMPLITUDE = 4.0m\n\nconst INPUT = Input(\n    box = Box{Shelf}(grid_size=(100, 50), phys_scale=150.0m),\n    time = TimeProperties(\n        Œît=0.0002Myr,\n        steps=5000,\n        write_interval=1),\n    ca_interval           = 1,\n\n    bedrock_elevation        = (x, y) -> -x / 300.0 ,\n    sea_level                = t -> AMPLITUDE * sin(2œÄ * t / PERIOD),\n    subsidence_rate          = 50.0m/Myr,\n    disintegration_rate      = 500.0m/Myr,\n    insolation               = 400.0u\"W/m^2\",\n    sediment_buffer_size     = 50,\n    depositional_resolution  = 0.5m,\n    facies                   = FACIES)\n\nmain(INPUT, \"data/alcaps2.h5\")","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"(Image: Result from alternative input)","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">file:<i>examples/alcaps/plot-alternative.jl</i></div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"#| creates: docs/src/_fig/alcaps-alternative.png\n#| requires: data/alcaps2.h5\n#| collect: figures\n\nusing CairoMakie\nusing Statistics\nusing GeometryBasics\nusing CarboKitten.Visualization\n\nfunction main()\n  fig = Visualization.sediment_profile(\"data/alcaps2.h5\", 25)\n  save(\"docs/src/_fig/alcaps-alternative.png\", fig)\nend\n\nmain()","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"</details>","category":"page"},{"location":"model-alcap/#ALCAPS-Module","page":"ALCAPS","title":"ALCAPS Module","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<details><summary>Module code</summary>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">file:<i>src/Model/ALCAPS.jl</i></div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"module ALCAPS\n\nusing Unitful\nusing HDF5\nusing ProgressBars\n\nusing ...BoundaryTrait: Shelf\nusing ...Config: Box, TimeProperties, axes\nusing ...SedimentStack: push_sediment!, pop_sediment!\nusing ...Burgess2013.CA: step_ca\nusing ...Burgess2013.Production: production_rate\nusing ...Transport.ActiveLayer: pde_stencil, Rate, Amount\nusing ...Utility: in_units_of\n\n<<alcaps>>\n\nend","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"</details>","category":"page"},{"location":"model-alcap/#Input","page":"ALCAPS","title":"Input","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"FIXME: Layout of this section","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"We'll go through the input options top-down.","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">‚™°alcaps‚™¢‚â£</div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"const Myr = u\"Myr\"\nconst m = u\"m\"\n\n<<alcaps-facies>>\n<<alcaps-sealevel>>\n\n@kwdef struct Input\n    <<alcaps-input>>\n    facies::Vector{Facies}    = FACIES\nend","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"box, default 100x50 with Shelf boundaries\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\nbox::Box              = Box{Shelf}(grid_size=(100, 50), phys_scale=150.0m)\ntime, default steps of 200yr over a period of 1Myr\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\ntime::TimeProperties  = TimeProperties(\n    Œît=0.0002Myr,\n    steps=5000,\n    write_interval=1)\nca_interval, how many steps between advancing the CA\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\nca_interval::Int      = 1\nbedrock_elevation, elevation of bedrock (unerodable initial material)\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\nbedrock_elevation     = (x, y) -> -x / 300.0  # (m, m) -> m\nsea_level, sea level as a function of time\n<div class=\"noweb-label\">‚™°alcaps-sealevel‚™¢‚â£</div>\nconst PERIOD = 0.2Myr\nconst AMPLITUDE = 4.0m\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\nsea_level             = t -> AMPLITUDE * sin(2œÄ * t / PERIOD)\nsubsidence_rate, how fast the plate is dropping\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\nsubsidence_rate::Rate = 50.0m/Myr\ndisintegration_rate, rate at which the top layer sediment is repurposed into the active layer\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\ndisintegration_rate::Rate = 500.0m/Myr   # same as maximum production rate\ninsolation\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\ninsolation::typeof(1.0u\"W/m^2\") = 400.0u\"W/m^2\"\nsediment_buffer_size, the depth in pixels of the sediment buffer\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\nsediment_buffer_size::Int     = 50\ndepositional_resolution, amount of sediment per pixel in the sediment buffer\n<div class=\"noweb-label\">‚™°alcaps-input‚™¢‚â£</div>\ndepositional_resolution::Amount = 0.5m","category":"page"},{"location":"model-alcap/#Facies","page":"ALCAPS","title":"Facies","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"The facies types, similar to values in Burgess 2013: viability range between 4 and 10 and activation range between 6 and 10 live cells. Each facies also has an associated diffusion_coefficient in units of meters.","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">‚™°alcaps-facies‚™¢‚â£</div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"@kwdef struct Facies\n    viability_range::Tuple{Int,Int}\n    activation_range::Tuple{Int,Int}\n\n    maximum_growth_rate::Rate\n    extinction_coefficient::typeof(1.0u\"m^-1\")\n    saturation_intensity::typeof(1.0u\"W/m^2\")\n\n    # though units are in m, this in not an amount.\n    # TODO: figure out what this unit means\n    # values should be picked rather large, say 10km.\n    diffusion_coefficient::typeof(1.0m)\nend\n\nconst FACIES = [\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 500u\"m/Myr\",\n           extinction_coefficient = 0.8u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\",\n           diffusion_coefficient = 1000u\"m\"),\n\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 400u\"m/Myr\",\n           extinction_coefficient = 0.1u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\",\n           diffusion_coefficient = 5000u\"m\"),\n\n    Facies(viability_range = (4, 10),\n           activation_range = (6, 10),\n           maximum_growth_rate = 100u\"m/Myr\",\n           extinction_coefficient = 0.005u\"m^-1\",\n           saturation_intensity = 60u\"W/m^2\",\n           diffusion_coefficient = 10000u\"m\")\n]","category":"page"},{"location":"model-alcap/#Logic","page":"ALCAPS","title":"Logic","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"The ALCAPS model tracks the CA state, sediment height and keeps a sediment buffer (see section on sediment buffers).","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">‚™°alcaps‚™¢‚â£</div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"mutable struct State\n    time::typeof(1.0u\"Myr\")\n\n    ca::Array{Int}\n    ca_priority::Vector{Int}\n\n    sediment_height::Array{Amount,2}   # x, y\n    # sediment_buffer stores fractions, so no units\n    sediment_buffer::Array{Float64,4}  # z, facies, x, y\nend","category":"page"},{"location":"model-alcap/#Initial-state","page":"ALCAPS","title":"Initial state","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"To construct the initial state, we forward the CA by 20 generations before starting the simulation proper.","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">‚™°alcaps‚™¢‚â£</div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"function initial_state(input)\n    sediment_height = zeros(Float64, input.box.grid_size...) * u\"m\"\n    n_facies = length(input.facies)\n    sediment_buffer = zeros(Float64, input.sediment_buffer_size, n_facies, input.box.grid_size...)\n\n    ca = rand(0:n_facies, input.box.grid_size...)\n    state = State(0.0u\"Myr\", ca, 1:n_facies, sediment_height, sediment_buffer)\n\n    for _ = 1:20\n        step_ca(input.box, input.facies)(state)\n    end\n\n    return state\nend","category":"page"},{"location":"model-alcap/#Disintegration","page":"ALCAPS","title":"Disintegration","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">‚™°alcaps‚™¢‚â£</div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"function disintegration(input)\n    n_facies = length(input.facies)\n    max_h = input.disintegration_rate * input.time.Œît\n    output = Array{Float64, 3}(undef, n_facies, input.box.grid_size...)\n\n    return function(state)\n        h = min.(max_h, state.sediment_height)\n        state.sediment_height .-= h\n        pop_sediment!(state.sediment_buffer, h ./ input.depositional_resolution .|> NoUnits, output)\n        return output .* input.depositional_resolution\n    end\nend","category":"page"},{"location":"model-alcap/#Production","page":"ALCAPS","title":"Production","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"Uses production rate function from Bosscher & Schlager 1992.","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">‚™°alcaps‚™¢‚â£</div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"function production(input)\n    n_facies = length(input.facies)\n    x, y = axes(input.box)\n    p(f, w) = production_rate(input.insolation, input.facies[f], w) .* input.time.Œît\n\n    w0 = .- input.bedrock_elevation.(x, y')\n    output = Array{Amount, 3}(undef, n_facies, input.box.grid_size...)\n\n    return function(state)\n        water_depth = w0 .+ input.sea_level(state.time) .-\n            state.sediment_height .+ input.subsidence_rate * state.time\n        for f = 1:n_facies\n            output[f, :, :] = ifelse.(state.ca .== f, p.(f, water_depth), 0.0m)\n        end\n        return output\n    end\nend","category":"page"},{"location":"model-alcap/#Transportation","page":"ALCAPS","title":"Transportation","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"Applies the Active-Layer transport method separately for each facies.","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">‚™°alcaps‚™¢‚â£</div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"function transportation(input)\n    n_facies = length(input.facies)\n    x, y = axes(input.box)\n    Œº0 = input.bedrock_elevation.(x, y')\n    # We always return this array\n    transported_output = Array{Amount, 3}(undef, n_facies, input.box.grid_size...)\n    stencils = [\n        let stc = pde_stencil(input.box, f.diffusion_coefficient)\n            (Œº, p) -> @views stc(tuple.(Œº, p[i,:,:]), transported_output[i,:,:])\n        end for (i, f) in enumerate(input.facies) ]\n\n    return function(state, active_layer::Array{Amount, 3})\n        Œº = state.sediment_height .+ Œº0\n        for stc in stencils\n            stc(Œº, active_layer)\n        end\n\n        return transported_output\n    end\nend","category":"page"},{"location":"model-alcap/#Main-loop","page":"ALCAPS","title":"Main loop","text":"","category":"section"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"Each iteration we:","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"Advance the CA (modifying CA state)\nProduce sediment into active layer\nDisintegrate older sediment into active layer (modifying sediment state)\nSolve for transport in active layer\nDeposit active layer (modifying sediment state)","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"<div class=\"noweb-label\">‚™°alcaps‚™¢‚â£</div>","category":"page"},{"location":"model-alcap/","page":"ALCAPS","title":"ALCAPS","text":"struct ModelFrame\n    disintegration::Array{Amount,3}    # facies, x, y\n    production::Array{Amount,3}\n    deposition::Array{Amount,3}\n    sediment_height::Array{Amount,2}\nend\n\nfunction run_model(input)\n    state = initial_state(input)\n    step_ca! = step_ca(input.box, input.facies)\n    disintegrate! = disintegration(input)\n    produce = production(input)\n    transport = transportation(input)\n\n    Channel{ModelFrame}() do ch\n        for i in ProgressBar(1:input.time.steps)\n            if mod(i, input.ca_interval) == 0\n                step_ca!(state)\n            end\n\n            p = produce(state)\n            d = disintegrate!(state)\n\n            active_layer = p .+ d\n            sediment = transport(state, active_layer)\n\n            push_sediment!(state.sediment_buffer, sediment ./ input.depositional_resolution .|> NoUnits)\n            state.sediment_height .+= sum(sediment; dims=1)[1,:,:]\n            state.time += input.time.Œît\n\n            put!(ch, ModelFrame(d, p, sediment, state.sediment_height))\n        end\n    end\nend\n\nfunction main(input::Input, output::String)\n    x, y = axes(input.box)\n    t = (0:input.time.steps) .* input.time.Œît\n\n    h5open(output, \"w\") do fid\n        gid = create_group(fid, \"input\")\n        gid[\"x\"] = collect(x) |> in_units_of(u\"m\")\n        gid[\"y\"] = collect(y) |> in_units_of(u\"m\")\n        gid[\"t\"] = t .|> in_units_of(u\"Myr\")\n        gid[\"bedrock_elevation\"] = input.bedrock_elevation.(x, y') |> in_units_of(u\"m\")\n        gid[\"sea_level\"] = input.sea_level.(t) .|> in_units_of(u\"m\")\n\n        attr = attributes(gid)\n        attr[\"delta_t\"] = input.time.Œît |> in_units_of(u\"Myr\")\n        attr[\"write_interval\"] = input.time.write_interval\n        attr[\"time_steps\"] = input.time.steps\n        attr[\"subsidence_rate\"] = input.subsidence_rate |> in_units_of(u\"m/Myr\")\n        attr[\"n_facies\"] = length(input.facies)\n\n        n_facies = length(input.facies)\n        ds_prod = create_dataset(fid, \"production\", datatype(Float64),\n            dataspace(n_facies, input.box.grid_size..., input.time.steps),\n            chunk=(n_facies, input.box.grid_size..., 1))\n        ds_disint = create_dataset(fid, \"disintegration\", datatype(Float64),\n            dataspace(n_facies, input.box.grid_size..., input.time.steps),\n            chunk=(n_facies, input.box.grid_size..., 1))\n        ds_sedim = create_dataset(fid, \"deposition\", datatype(Float64),\n            dataspace(n_facies, input.box.grid_size..., input.time.steps),\n            chunk=(n_facies, input.box.grid_size..., 1))\n        ds_height = create_dataset(fid, \"sediment_height\", datatype(Float64),\n            dataspace(input.box.grid_size..., input.time.steps),\n            chunk=(input.box.grid_size..., 1))\n\n        results = run_model(input)\n        for (step, frame) in enumerate(results)\n            ds_prod[:, :, :, step] = frame.production |> in_units_of(u\"m\")\n            ds_disint[:, :, :, step] = frame.disintegration |> in_units_of(u\"m\")\n            ds_sedim[:, :, :, step] = frame.deposition |> in_units_of(u\"m\")\n            ds_height[:, :, step] = frame.sediment_height |> in_units_of(u\"m\")\n        end\n    end\nend","category":"page"},{"location":"utility/#Utility-functions","page":"Utility","title":"Utility functions","text":"","category":"section"},{"location":"utility/#Select-Iterator","page":"Utility","title":"Select Iterator","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"In many cases our model is updating some state as an iterator. I want to be able to select arbitrary slices from that iterator. The Select object contains the main iterable and a selection iterable that should yield integers. When iterated upon, we repeatedly use Iterators.dropwhile to get to the next index.","category":"page"},{"location":"utility/","page":"Utility","title":"Utility","text":"<div class=\"noweb-label\">file:<i>src/Utility.jl</i></div>","category":"page"},{"location":"utility/","page":"Utility","title":"Utility","text":"module Utility\n\nexport select, in_units_of\nusing Unitful\n\nstruct Select\n    iter\n    selection\nend\n\nfunction select(it, sel)\n    Select(enumerate(it), sel)\nend\n\nfunction Base.iterate(s::Select)\n    x = iterate(s.selection)\n    if x !== nothing\n        (idx, selstate) = x\n        ((_, value), rest) = Iterators.peel(Iterators.dropwhile(((i, y),) -> i != idx, s.iter))\n        return (value, (selstate, rest))\n    else\n        return nothing\n    end\nend\n\nfunction Base.iterate(s::Select, state)\n    (selstate, rest) = state\n    x = iterate(s.selection, selstate)\n    if x !== nothing\n        (idx, selstate) = x\n        ((_, value), rest) = Iterators.peel(Iterators.dropwhile(((i, y),) -> i != idx, s.iter))\n        return (value, (selstate, rest))\n    else\n        return nothing\n    end\nend\n\n<<utility>>\n\nend","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"title: Species Habitation subtitle: a cellular automaton ‚Äì-","category":"page"},{"location":"carbocat-ca/#Cellular-Automaton","page":"Cellular Automaton","title":"Cellular Automaton","text":"","category":"section"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"The paper talks about cycling the order of preference for occupying an empty cell at each iteration. This means that the rules change slightly every iteration.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">‚™°cycle-permutation‚™¢‚â£</div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"cycle_permutation(n_species::Int) =\n    (circshift(1:n_species, x) for x in Iterators.countfrom(0))","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"The stencil function has an args... variadic arguments that are forwarded to the given rule. This means we can create a rules function that we pass the preference order as a second argument.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">‚™°burgess2013-rules‚™¢‚â£</div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"function rules(facies::Vector{F}) where {F}\n    function (neighbourhood::Matrix{Int}, order::Vector{Int})\n        cell_facies = neighbourhood[3, 3]\n        neighbour_count(f) = sum(neighbourhood .== f)\n        if cell_facies == 0\n            for f in order\n                n = neighbour_count(f)\n                (a, b) = facies[f].activation_range\n                if a <= n && n <= b\n                    return f\n                end\n            end\n            0\n        else\n            n = neighbour_count(cell_facies) - 1\n            (a, b) = facies[cell_facies].viability_range\n            (a <= n && n <= b ? cell_facies : 0)\n        end\n    end\nend\n\n<<ca-stateful>>\n\nfunction run_ca(::Type{B}, facies::Vector{F}, init::Matrix{Int}, n_species::Int) where {B<:Boundary{2}, F}\n    r = rules(facies)\n    Channel{Matrix{Int}}() do ch\n        target = Matrix{Int}(undef, size(init))\n        put!(ch, init)\n        stencil_op = stencil(Int, B, (5, 5), r)\n        for perm in cycle_permutation(n_species)\n            stencil_op(init, target, perm)\n            init, target = target, init\n            put!(ch, init)\n        end\n    end\nend","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"This function is not yet adaptible to the given rule set. Such a modification is not so hard to make.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"The paper talks about a 50x50 grid initialized with uniform random values.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">file:<i>src/Burgess2013/CA.jl</i></div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"module CA\n\nusing ...BoundaryTrait\nusing ...Stencil\nusing ..Config: Facies\nusing ...Config: Box\n\nexport run_ca\n\n<<cycle-permutation>>\n<<burgess2013-rules>>\n\nend","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"First, let us reproduce Figure 3 in Burgess 2013.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"(Image: First 8 generations)","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"By eye comparison seems to indicate that this CA is working the same. I'm curious to the behaviour after more iterations. Let's try 10, 100, 10000 and so on.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"(Image: Assymptotic behaviour)","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"The little qualitative change between 100 and 1000 iterations would indicate that this CA remains \"interesting\" for a long time.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"On my laptop I can run about 150 iterations per second with current code. When using periodic boundaries, I get to 1500 iterations per second, which is peculiar. A lot can still be optimized.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<details><summary>Plotting code</summary>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">file:<i>examples/ca/burgess-2013.jl</i></div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"module Script\n    using .Iterators: flatten\n    using CarboKitten\n    using CarboKitten.Burgess2013\n    using CarboKitten.Stencil: Reflected\n    using CarboKitten.Utility\n    using GLMakie\n\n    function main()\n        init = rand(0:3, 50, 50)\n        ca = run_ca(Reflected{2}, MODEL1, init, 3)\n\n        fig = Figure(resolution=(1000, 500))\n        axis_indices = flatten(eachrow(CartesianIndices((2, 4))))\n        for (i, st) in zip(axis_indices, ca)\n            ax = Axis(fig[Tuple(i)...], aspect=AxisAspect(1))\n            heatmap!(ax, st)\n        end\n        save(\"docs/src/_fig/b13-fig3.png\", fig)\n    end\nend\n\nScript.main()","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">file:<i>examples/ca/long-term.jl</i></div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"module Script\n    using CarboKitten\n    using CarboKitten.Burgess2013\n    using CarboKitten.Stencil\n    using CarboKitten.Utility\n    using GLMakie\n\n    function main()\n        init = rand(0:3, 50, 50)\n        result = select(run_ca(Periodic{2}, MODEL1, init, 3), [10, 100, 10000])\n\n        fig = Figure(resolution=(1000, 333))\n        for (i, st) in enumerate(result)\n            ax = Axis(fig[1, i], aspect=AxisAspect(1))\n            heatmap!(ax, st)\n        end\n        save(\"docs/src/_fig/b13-long-term.png\", fig)\n    end\nend\n\nScript.main()","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"</details>","category":"page"},{"location":"carbocat-ca/#How-to-run","page":"Cellular Automaton","title":"How to run","text":"","category":"section"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"We start with randomized initial conditions on a 50x50 grid.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"using CarboKitten.Stencil: Reflected\nusing CarboKitten.Burgess2013\ninit = rand(0:3, 50, 50)\nresult = Iterators.take(run_ca(Reflected{2}, MODEL1, init, 3), 8)","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"Then we run the cellular automaton for, in this case eight generations. The CA.run function returns an iterator of 50x50 maps. That means that in principle we can extract an infinity of iterations, but in this cane we only take eight.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"result = Iterators.take(CA.run(Reflected{2}, init, 3), 8)","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"In Julia we may plot those as follows","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"using Plots\n# plotly()  # sets back-end; plotly gives me the best results\nplot((heatmap(r, colorbar=:none) for r in result)..., layout=(2, 4))","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"What this says is: create a heatmap for each of our eight results, then expand those into a function call to plot (as in plot(hm1, hm2, ..., hm8, layout=(2, 4))).","category":"page"},{"location":"carbocat-ca/#Statuful-API","page":"Cellular Automaton","title":"Statuful API","text":"","category":"section"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"For most applications in CarboKitten it is most useful to have a CA that updates some state struct in-place. This way any module that needs access to the CA state can do so.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">‚™°ca-stateful‚™¢‚â£</div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"function step_ca(box::Box{BT}, facies) where {BT<:Boundary{2}}\n    \"\"\"Creates a propagator for the state, updating the celullar automaton in place.\n\n    Contract: the `state` should have `ca::Matrix{Int}` and `ca_priority::Vector{Int}`\n    members.\"\"\"\n    r = rules(facies)\n    tmp = Matrix{Int}(undef, box.grid_size)\n    stencil_op = stencil(Int, BT, (5, 5), r)\n\n    function (state)\n        stencil_op(state.ca, tmp, state.ca_priority)\n        state.ca, tmp = tmp, state.ca\n        state.ca_priority = circshift(state.ca_priority, 1)\n    end\nend","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"We may test that running the above function ten times gives the same result as the tenth result from the iterator API.","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"<div class=\"noweb-label\">file:<i>test/CASpec.jl</i></div>","category":"page"},{"location":"carbocat-ca/","page":"Cellular Automaton","title":"Cellular Automaton","text":"@testset \"CA\" begin\n    using CarboKitten.BoundaryTrait: Periodic\n    using CarboKitten.Config: Box\n    using CarboKitten.Burgess2013.Config: MODEL1\n    using CarboKitten.Burgess2013.CA: step_ca, run_ca\n    using Unitful\n\n    mutable struct State\n        ca::Matrix{Int}\n        ca_priority::Vector{Int}\n    end\n\n    n_facies = length(MODEL1)\n    box = Box{Periodic{2}}(grid_size=(50, 50), phys_scale=100.0u\"m\")\n    ca_init = rand(0:n_facies, box.grid_size...)\n    ca_channel = run_ca(Periodic{2}, MODEL1, copy(ca_init), n_facies)\n    item1, _ = Iterators.peel(Iterators.drop(ca_channel, 20))\n\n    ca_step = step_ca(box, MODEL1)\n    state = State(copy(ca_init), 1:n_facies)\n    for _ in 1:20\n        ca_step(state)\n    end\n\n    @test item1 == state.ca\nend","category":"page"},{"location":"boxes/#Generic-Parameters","page":"Boxes","title":"Generic Parameters","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">file:<i>src/Config.jl</i></div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"module Config\n\nexport AbstractBox, Box\n\nusing ..BoundaryTrait\nusing ..Vectors\n\nusing Unitful\nusing Unitful.DefaultSymbols\n\n<<config-types>>\n\nend","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Physical parameters of CarboKitten all should have units, see our refresher on Unitful.jl.","category":"page"},{"location":"boxes/#Box-topology","page":"Boxes","title":"Box topology","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"CarboKitten has a 3-dimensional state space, where two dimensions represent cartesian topographic coordinates, and the third dimension is a track record of sedimentation. The cartesian topographic coordinates are always on a regular grid, but depending on the scenario you may choose different map topologies.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"periodic boundaries To study sedimentation in a small isolated patch, periodic boundaries seem sufficient. The field is assumed to be infinite in all directions.\nVon Neumann boundaries In the case of an island it is nicer to have boundaries with constant derivatives. Produced sediment that flows out of the box is lost to the seas.\ncoastal shelf boundaries Supposing we simulate a narrow cross section of a carbonate shelf, we'll have one periodic boundary (in y-direction) and Von Neumann boundaries in the x-direction.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"We parametrize these boundaries as type-level constants in Julia. This way we can use the multiple dispatch mechanism in Julia to obtain specialized implementations for each boundary case, selected at compile time, resulting in efficient run-times.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°boundary-types‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"abstract type Boundary{dim} end\nstruct Reflected{dim} <: Boundary{dim} end\nstruct Periodic{dim} <: Boundary{dim} end\nstruct Constant{dim,value} <: Boundary{dim} end\nstruct Shelf <: Boundary{2} end","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"The Boundary type is part of the generic Box dimension specification.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°config-types‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"abstract type AbstractBox{BT} end\n\nstruct Box{BT} <: AbstractBox{BT}\n    grid_size::NTuple{2,Int}\n    phys_scale::typeof(1.0m)\n    phys_size::Vec2\n\n    function Box{BT}(;grid_size::NTuple{2, Int}, phys_scale::Quantity{Float64, ùêã, U}) where {BT <: Boundary{2}, U}\n        new{BT}(grid_size, phys_scale, phys_size(grid_size, phys_scale))\n    end\nend\n\nfunction axes(box::Box)\n\ty_axis = (0:(box.grid_size[2] - 1)) .* box.phys_scale\n\tx_axis = (0:(box.grid_size[1] - 1)) .* box.phys_scale\n\treturn x_axis, y_axis\nend\n\nphys_size(grid_size, phys_scale) = (\n    x = grid_size[1] * (phys_scale / m |> NoUnits),\n    y = grid_size[2] * (phys_scale / m |> NoUnits))","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Now we can specify the box parameters as follows:","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">file:<i>test/ConfigSpec.jl</i></div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"@testset \"Config\" begin\n    using CarboKitten.BoundaryTrait\n    using CarboKitten.Config: Box\n    using CarboKitten.Vectors\n\n    box = Box{Shelf}(\n        grid_size = (100, 50),\n        phys_scale = 1.0u\"km\")\n    @test box.phys_size == (x=100000.0, y=50000.0)\nend","category":"page"},{"location":"boxes/#Time-properties","page":"Boxes","title":"Time properties","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Time stepping is specified in TimeProperties. We'll have time_steps number of time steps, each of physical time Œît. However, only one in write_interval steps is written to disk.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°config-types‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"abstract type AbstractTimeProperties end\n\n@kwdef struct TimeProperties <: AbstractTimeProperties\n    Œît::typeof(1.0u\"Myr\")\n    steps::Int\n    write_interval::Int\nend","category":"page"},{"location":"boxes/#Vectors","page":"Boxes","title":"Vectors","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"To trace the position of particles we define a NamedTuple with x and y members and define common vector operations on those.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">file:<i>src/Vectors.jl</i></div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"module Vectors\n\nexport Vec2\n\nVec2 = @NamedTuple{x::Float64, y::Float64}\nBase.:+(a::Vec2, b::Vec2) = (x=a.x+b.x, y=a.y+b.y)\nBase.abs2(a::Vec2) = a.x^2 + a.y^2\nBase.abs(a::Vec2) = ‚àö(abs2(a))\nBase.:*(a::Vec2, b::Float64) = (x=a.x*b, y=a.y*b)\nBase.:/(a::Vec2, b::Float64) = (x=a.x/b, y=a.y/b)\nBase.:*(a::Float64, b::Vec2) = b*a\nBase.:-(a::Vec2, b::Vec2) = (x=a.x-b.x, y=a.y-b.y)\nBase.:-(a::Vec2) = (x=-a.x, y=-a.y)\nBase.zero(::Type{Vec2}) = (x=0.0, y=0.0)\n\nend","category":"page"},{"location":"boxes/#Offset-indexing","page":"Boxes","title":"Offset indexing","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Now we can use these traits to define three methods for indexing on an offset from some index that is assumed to be within bounds.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°spec‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"@testset \"offset_value\" begin\n    @test CartesianIndex(1, 1) == offset_index(Reflected{2}, (3, 3), CartesianIndex(1, 1), CartesianIndex(0, 0))\nend","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°offset-indexing‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"function offset_index(::Type{BT}, shape::NTuple{dim,Int}, i::CartesianIndex, Œîi::CartesianIndex) where {dim, BT <: Boundary{dim}}\n    canonical(BT, shape, i + Œîi)\nend\n\nfunction offset_value(BT::Type{B}, z::AbstractArray, i::CartesianIndex, Œîi::CartesianIndex) where {dim,B<:Boundary{dim}}\n    z[offset_index(BT, size(z), i, Œîi)]\nend\n\nfunction offset_value(::Type{Constant{dim,value}}, z::AbstractArray, i::CartesianIndex, Œîi::CartesianIndex) where {dim,value}\n    j = i + Œîi\n    (checkbounds(Bool, z, j) ? z[j] : value)\nend","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">file:<i>src/BoundaryTrait.jl</i></div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"module BoundaryTrait\n\nexport Boundary, Reflected, Periodic, Constant, Shelf, offset_index, offset_value, canonical\n\n<<boundary-types>>\n<<offset-indexing>>\n<<canonical-coordinates>>\n\nend","category":"page"},{"location":"boxes/#Canonical-coordinates","page":"Boxes","title":"Canonical coordinates","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"For both Periodic and Reflected boundaries it is also possible to write a function that makes any coordinate within bounds. This uses the fact that reflected boundaries are also periodic for a box twice the size.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°canonical-coordinates‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"function canonical(::Type{Periodic{dim}}, shape::NTuple{dim,Int}, i::CartesianIndex) where {dim}\n    CartesianIndex(mod1.(Tuple(i), shape)...)\nend\n\nfunction canonical(::Type{Reflected{dim}}, shape::NTuple{dim,Int}, i::CartesianIndex) where {dim}\n    modflip(a, l) = let b = mod1(a, 2l)\n        b > l ? 2l - b + 1 : b\n    end\n    CartesianIndex(modflip.(Tuple(i), shape)...) \nend\n\nfunction canonical(::Type{Constant{dim, value}}, shape::NTuple{dim,Int}, i::CartesianIndex) where {dim, value}\n    all(checkindex.(Bool, range.(1, shape), Tuple(i))) ? i : nothing\nend","category":"page"},{"location":"boxes/#Shelf-boundary","page":"Boxes","title":"Shelf boundary","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"The Shelf boundary type is specially designed for the simulation of a transect perpendicular to the coast direction. We are periodic in the y-direction and have a Neumannesque constant boundary at the edges of the simulation area.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°offset-indexing‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"function canonical(::Type{Shelf}, shape::NTuple{2, Int}, i::CartesianIndex)\n    if i[1] < 1 || i[1] > shape[1]\n        return nothing\n    end\n    return CartesianIndex(i[1], mod1(i[2], shape[2]))\nend\n\nfunction offset_value(::Type{Shelf}, z::AbstractArray, i::CartesianIndex, Œîi::CartesianIndex)\n    j = i + Œîi\n    shape = size(z)\n    if j[1] < 1\n        return z[1, mod1(j[2], shape[2])]\n    elseif j[1] > shape[1]\n        return z[shape[1], mod1(j[2], shape[2])]\n    else\n        return z[j[1], mod1(j[2], shape[2])]\n    end\nend","category":"page"},{"location":"boxes/#Boxes","page":"Boxes","title":"Boxes","text":"","category":"section"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"We need to define how particles move past boundaries. Similar to the grid based offset_index method, we define the offset method for a Vec2.","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"<div class=\"noweb-label\">‚™°vector-offset‚™¢‚â£</div>","category":"page"},{"location":"boxes/","page":"Boxes","title":"Boxes","text":"Base.in(a::Vec2, box::Box) =\n    a.x >= 0.0 && a.x < box.phys_size.x && a.y >= 0.0 && a.y < box.phys_size.y\n\nfunction offset(box::AbstractBox{Reflected{2}}, a::Vec2, Œîa::Vec2)\n    clip(i, a, b) = (i < a ? a + a - i : (i > b ? b + b - i : i))\n    (x=clip(a.x+Œîa.x, 0.0, box.phys_size.x)\n    ,y=clip(a.y+Œîa.y, 0.0, box.phys_size.y))\nend\n\nfunction offset(box::AbstractBox{Periodic{2}}, a::Vec2, Œîa::Vec2)\n    (x=mod(a.x+Œîa.x, box.phys_size.x)\n    ,y=mod(a.y+Œîa.y, box.phys_size.y))\nend\n\nfunction offset(box::AbstractBox{Constant{2,Value}}, a::Vec2, Œîa::Vec2) where Value\n    b = a + Œîa\n    if b ‚àâ box\n        nothing\n    else\n        b\n    end\nend\n\nfunction offset(box::AbstractBox{Shelf}, a::Vec2, Œîa::Vec2)\n    b = a + Œîa\n    if b.x < 0.0 || b.x >= box.phys_size.x\n        nothing\n    else\n        (x=b.x, y=mod(b.y, box.phys_size.y))\n    end\nend","category":"page"},{"location":"ca-with-production/#Combining-CA-with-production","page":"Model with CA and Production","title":"Combining CA with production","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"This model combines BS92 production with the B13 cellular automaton.","category":"page"},{"location":"ca-with-production/#Complete-example","page":"Model with CA and Production","title":"Complete example","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"This example is running for 10000 steps to 1Myr on a 100 times 50 grid, starting with a sloped height down to 50m. The sea_level, and initial_depth arguments are functions. The phys_scale argument translate pixels on the grid into physical metres. The write_interval indicates to write output every 10 iterations, summing the production over that range. You may copy paste the following code into your own script or notebook, and play around with input values.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/production-only/caps-osc.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: data/caps-osc.h5\n#| requires: src/CaProd.jl\n\nmodule Script\nusing CarboKitten.BoundaryTrait: Shelf\nusing CarboKitten.Config: Box, TimeProperties\nusing CarboKitten.Burgess2013.Config: MODEL1\nusing CarboKitten.CaProd\nusing Unitful\n\nconst PERIOD = 200.0u\"kyr\"\nconst AMPLITUDE = 4.0u\"m\"\n\nconst DEFAULT_INPUT = CaProd.Input(\n  box = Box{Shelf}(\n    grid_size = (100, 50),\n    phys_scale = 0.15u\"km\"\n    # equivalent:\n    # phys_scale = 150\"m\"\n  ),\n  time = TimeProperties(\n    Œît = 0.0001u\"Myr\",\n    # equivalent: \n    # Œît = 1u\"kyr\",\n    steps = 10000,\n    write_interval = 10\n  ),\n  sea_level = t -> AMPLITUDE * sin(2œÄ * t / PERIOD), \n  subsidence_rate=50.0u\"m/Myr\",\n  initial_depth=x -> x / 300.0,\n  facies=MODEL1,\n  insolation=400.0u\"W/m^2\"\n)\nend\n\nScript.CaProd.main(Script.DEFAULT_INPUT, \"data/caps-osc.h5\")","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"This writes output to an HDF5 file that you may use for further analysis and visualization.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/plot-caps-osc.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: docs/src/_fig/b13-capsosc-crosssection.png\n#| requires: data/caps-osc.h5 ext/VisualizationExt.jl\n#| collect: figures\n\nmodule Script\n    using CairoMakie\n    using GeometryBasics\n    using CarboKitten.Visualization\n\n    function main()\n        f = Figure()\n        plot_crosssection(f[1,1], \"data/caps-osc.h5\")\n\t      save(\"docs/src/_fig/b13-capsosc-crosssection.png\", f)\n    end\nend\n\nScript.main()","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"(Image: Stratigraphy, production and subsidence under oscillating sea level.)","category":"page"},{"location":"ca-with-production/#Input","page":"Model with CA and Production","title":"Input","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"initial depth (function of space)\nsea-level curve (function of time)\nsubsidence (function of time)\nfacies types","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"These should all behave as a functions, but could also be some interpolated data. The signs of these quantities should be such that the following equation holds:","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"T + E = S + W","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"Saying Tectonic subsidence plus Eustatic sea-level change equals Sedimentation plus change in Water depth.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-input‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"@kwdef struct Input\n    box::Box\n    time::TimeProperties\n\n    sea_level       # Myr -> m\n    subsidence_rate::typeof(1.0u\"m/Myr\")\n    initial_depth   # m -> m\n\n    facies::Vector{Facies}\n    insolation::typeof(1.0u\"W/m^2\")\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"In the case write_interval is not one, we will sum production rates over several iterations of the model before writing to output. In that case sediment production per written frame is no longer limited to a single facies.","category":"page"},{"location":"ca-with-production/#Output","page":"Model with CA and Production","title":"Output","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"Each iteration of the model, we produce a Frame.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-frame‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"struct Frame\n    production::Array{typeof(1.0u\"m/Myr\"),3}\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The frame is used to update a state S. The frame should be considered a delta for the state. So, we can reproduce the height at each step from the frames.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-state‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"mutable struct State\n    time::typeof(1.0u\"Myr\")\n    ca::Array{Int}\n    ca_priority::Vector{Int}\n    height::Array{typeof(1.0u\"m\"),2}\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The output is principally all frames produced in the simulation, in a 4-dimensional array. The first two dimensions are x, y positions on the grid, the third is the facies and the fourth dimension is time. We store the output in HDF5, having an input group where we store the input data, and a sediment dataset containing the aforementioned 4-dimensional output data. Note that these are production rates, so to reconstruct the sea floor depth at any time, you need to multiply by Delta t * n_w, where n_w is the write_interval and take a cumulative sum.","category":"page"},{"location":"ca-with-production/#Logic","page":"Model with CA and Production","title":"Logic","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"From a dynamical modeling point of view, CarboCAT operates analogous to a forward Euler integration scheme, where some components are actually a discrete model. This means we have one function that generates a Frame from a State, called the propagator P (this is our own nomenclature),","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"P_i S to Delta","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The suffix i here is used to indicate that the propagator depends on the input. We'll have a second function U that updates the state with the given frame,","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"U (S Delta) to S","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"In practice however, the update function changes the state in-place.","category":"page"},{"location":"ca-with-production/#Init","page":"Model with CA and Production","title":"Init","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"We fill the height map with the initial depth function. It is assumed that the height only depends on the second index.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-model‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"function initial_state(input)  # -> State\n    height = zeros(Float64, input.box.grid_size...) * u\"m\"\n    for i in CartesianIndices(height)\n        height[i] = input.initial_depth(i[1] * input.box.phys_scale)\n    end\n\n    n_facies = length(input.facies)\n    ca = rand(0:n_facies, input.box.grid_size...)\n    state = State(0.0u\"Myr\", ca, 1:n_facies, height)\n\n    step = step_ca(input.box, input.facies)\n    for _ = 1:20\n        step(state)\n    end\n\n    return state\nend","category":"page"},{"location":"ca-with-production/#Propagator","page":"Model with CA and Production","title":"Propagator","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The propagator computes the production rates (and also erosion) given the state of the model.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-model‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"function propagator(input)\n    <<ca-prod-init-propagator>>\n    function (s)  # -> Frame\n        <<ca-prod-propagate>>\n    end\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The propagator keeps the cellular automaton as an internal state, but this may also be considered to be an input function. This may change when you'd want to influence the CA with environmental factors. Then the CA becomes an integral component of the dynamical model. The CA would then have to keep state in the State variable. We burn the first 20 iterations of the CA to start with a realistic pattern.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-init-propagator‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"n_facies = length(input.facies)\n\nfunction water_depth(s)\n    s.height .- input.sea_level(s.time)\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"Now, to generate a production from a given state, we advance the CA by one step and compute the production accordingly.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-propagate‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"result = zeros(typeof(0.0u\"m/Myr\"), input.box.grid_size..., n_facies)\nw = water_depth(s)\nfor idx in CartesianIndices(s.ca)\n    f = s.ca[idx]\n    if f == 0\n        continue\n    end\n    result[Tuple(idx)..., f] = production_rate(input.insolation, input.facies[f], w[idx])\nend\nreturn Frame(result)","category":"page"},{"location":"ca-with-production/#Updater","page":"Model with CA and Production","title":"Updater","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"Every iteration we update the height variable with the subsidence rate, and add sediments to the height.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-model‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"function updater(input::Input)\n    n_facies = length(input.facies)\n    function (s::State, Œî::Frame)\n        s.height .-= sum(Œî.production; dims=3) .* input.time.Œît\n        s.height .+= input.subsidence_rate * input.time.Œît\n        s.time += input.time.Œît\n    end\nend","category":"page"},{"location":"ca-with-production/#Loop","page":"Model with CA and Production","title":"Loop","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">‚™°ca-prod-model‚™¢‚â£</div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"function run_model(input::Input)\n    Channel{Frame}() do ch\n        s = initial_state(input)\n        p_production = propagator(input)\n        p_ca! = step_ca(input.box, input.facies)\n        u! = updater(input)\n\n        while true\n            p_ca!(s)\n\n            Œî = p_production(s)\n            put!(ch, Œî)\n            u!(s, Œî)\n        end\n    end\nend","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>src/CaProd.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"module CaProd\n\nusing CarboKitten\nusing ..Utility\nusing ..Config: Box, TimeProperties\nusing ..BoundaryTrait: Periodic\nusing ..Utility\n# using CarboKitten.BS92: sealevel_curve\nusing ..Stencil\nusing ..Burgess2013\nusing ..Burgess2013.CA: step_ca\n\nusing HDF5\nusing Unitful\nusing .Iterators: drop, peel, partition, map, take\n\n<<ca-prod-input>>\n<<ca-prod-frame>>\n<<ca-prod-state>>\n<<ca-prod-model>>\n\nfunction stack_frames(fs::Vector{Frame})  # -> Frame\n    Frame(sum(f.production for f in fs))\nend\n\nfunction main(input::Input, output::String)\n    y_axis = (0:(input.box.grid_size[2]-1)) .* input.box.phys_scale\n    x_axis = (0:(input.box.grid_size[1]-1)) .* input.box.phys_scale\n    initial_height = input.initial_depth.(x_axis)\n    n_writes = input.time.steps √∑ input.time.write_interval\n\n    h5open(output, \"w\") do fid\n        gid = create_group(fid, \"input\")\n        gid[\"x\"] = collect(x_axis) |> in_units_of(u\"m\")\n        gid[\"y\"] = collect(y_axis) |> in_units_of(u\"m\")\n        gid[\"height\"] = collect(initial_height) |> in_units_of(u\"m\")\n        gid[\"t\"] = collect((0:(n_writes-1)) .* (input.time.Œît * input.time.write_interval)) |> in_units_of(u\"Myr\")\n        attr = attributes(gid)\n        attr[\"delta_t\"] = input.time.Œît |> in_units_of(u\"Myr\")\n        attr[\"write_interval\"] = input.time.write_interval\n        attr[\"time_steps\"] = input.time.steps\n        attr[\"subsidence_rate\"] = input.subsidence_rate |> in_units_of(u\"m/Myr\")\n        attr[\"n_facies\"] = length(input.facies)\n\n        n_facies = length(input.facies)\n        ds = create_dataset(fid, \"sediment\", datatype(Float64),\n            dataspace(input.box.grid_size..., n_facies, input.time.steps),\n            chunk=(input.box.grid_size..., n_facies, 1))\n\n        results = map(stack_frames, partition(run_model(input), input.time.write_interval))\n        for (step, frame) in enumerate(take(results, n_writes))\n            ds[:, :, :, step] = frame.production |> in_units_of(u\"m/Myr\")\n        end\n    end\nend\n\nend # CaProd","category":"page"},{"location":"ca-with-production/#Case-1","page":"Model with CA and Production","title":"Case 1","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"The first case uses the same settings as Burgess 2013: an initial depth of 2m, subsidence rate of 50 m/Myr and constant sea level.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/production-only/ca-uniform.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: data/ca-prod.h5\n#| requires: src/CaProd.jl\n\nmodule Script\nusing CarboKitten.CaProd\nusing CarboKitten.BoundaryTrait\nusing CarboKitten.Config: Box, TimeProperties\nusing CarboKitten.Burgess2013.Config: MODEL1\nusing Unitful\n\nconst DEFAULT_INPUT = CaProd.Input(\n  box = Box{Periodic{2}}(\n    grid_size = (50, 50),\n    phys_scale = 1.0u\"m\"\n  ),\n  time = TimeProperties(\n    Œît = 0.001u\"Myr\",\n    steps = 1000,\n    write_interval = 1\n  ),\n  sea_level=_ -> 0.0u\"m\",\n  subsidence_rate=50.0u\"m/Myr\",\n  initial_depth=_ -> 2.0u\"m\",\n  facies=MODEL1,\n  insolation=2000.0u\"W/m^2\"\n)\nend\n\nCaProd.main(Script.DEFAULT_INPUT, \"data/ca-prod.h5\")","category":"page"},{"location":"ca-with-production/#Case-2","page":"Model with CA and Production","title":"Case 2","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"For the second case, we start with a slope.","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/production-only/ca-slope.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: data/ca-prod-slope.h5\n#| requires: src/CaProd.jl\n\nmodule Script\nusing CarboKitten.BoundaryTrait: Shelf\nusing CarboKitten.Config: Box, TimeProperties\nusing CarboKitten.Burgess2013.Config: MODEL1\nusing CarboKitten.CaProd\nusing Unitful\n\nconst DEFAULT_INPUT = CaProd.Input(\n  box = Box{Shelf}(\n    grid_size = (100, 50),\n    phys_scale = 0.15u\"km\"\n  ),\n  time = TimeProperties(\n    Œît = 0.001u\"Myr\",\n    steps = 1000,\n    write_interval = 1\n  ),\n  sea_level=_ -> 0.0u\"m\",\n  subsidence_rate=50.0u\"m/Myr\",\n  initial_depth=x -> x / 300.0,\n  facies=MODEL1,\n  insolation=400.0u\"W/m^2\"\n)\nend\n\nScript.CaProd.main(Script.DEFAULT_INPUT, \"data/ca-prod-slope.h5\")","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>examples/production-only/plot-cap-slope.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"#| creates: docs/src/_fig/b13-crosssection.png\n#| requires: data/ca-prod-slope.h5 ext/VisualizationExt.jl\n#| collect: figures\n\nmodule Script\nusing CairoMakie\nusing CarboKitten.Visualization\n\nfunction main()\n    f = Figure()\n    plot_crosssection(f[1, 1], \"data/ca-prod-slope.h5\")\n    save(\"docs/src/_fig/b13-crosssection.png\", f)\nend\nend\n\nScript.main()","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"(Image: Stratigraphy; production and subsidence.)","category":"page"},{"location":"ca-with-production/#Visualizing-output","page":"Model with CA and Production","title":"Visualizing output","text":"","category":"section"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>src/Visualization.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"module Visualization\n    export plot_crosssection, plot_facies_production, sediment_profile\n\n    print_instructions() = print(\"This is an extension and only becomes available when you import {Cairo,GL,WGL}Makie before using this.\\n\")\n\n    plot_facies_production(args...) = print_instructions()\n    plot_crosssection(args...) = print_instructions()\n    sediment_profile!(args...) = print_instructions()\n    sediment_profile(args...) = print_instructions()\nend  # module","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"<div class=\"noweb-label\">file:<i>ext/VisualizationExt.jl</i></div>","category":"page"},{"location":"ca-with-production/","page":"Model with CA and Production","title":"Model with CA and Production","text":"module VisualizationExt\n\nimport CarboKitten.Visualization: plot_facies_production, plot_crosssection, sediment_profile\n\nusing CarboKitten\nusing CarboKitten.Visualization\nusing CarboKitten.Burgess2013: production_rate\nusing CarboKitten.Utility: in_units_of\n\nusing HDF5\nusing Makie\nusing GeometryBasics\nusing Unitful\n\nusing Statistics: mean\n\nconst Rate = typeof(1.0u\"m/Myr\")\nconst Amount = typeof(1.0u\"m\")\nconst Length = typeof(1.0u\"m\")\nconst Time = typeof(1.0u\"Myr\")\n\nconst na = [CartesianIndex()]\n\nstruct Axes\n\tx::Vector{Length}\n\ty::Vector{Length}\n\tt::Vector{Time}\nend\n\nstruct Header\n\taxes::Axes\n\tŒît::Time\n\ttime_steps::Int\n\tbedrock_elevation::Matrix{Amount}\n\tsea_level::Vector{Length}\n\tsubsidence_rate::Rate\nend\n\nstruct Data\n\tdisintegration::Array{Amount, 4}\n\tproduction::Array{Amount, 4}\n\tdeposition::Array{Amount, 4}\n\tsediment_elevation::Array{Amount, 3}\nend\n\nstruct DataSlice\n\tdisintegration::Array{Amount, 3}\n\tproduction::Array{Amount, 3}\n\tdeposition::Array{Amount, 3}\n\tsediment_elevation::Array{Amount, 2}\nend\n\nfunction read_header(fid)\n\tattrs = HDF5.attributes(fid[\"input\"])\n\n\taxes = Axes(\n\t\tfid[\"input/x\"][]*u\"m\",\n\t\tfid[\"input/y\"][]*u\"m\",\n\t\tfid[\"input/t\"][]*u\"Myr\")\n\n\treturn Header(\n\t\taxes,\n\t\tattrs[\"delta_t\"][]*u\"Myr\",\n\t\tattrs[\"time_steps\"][],\n\t\tfid[\"input/bedrock_elevation\"][]*u\"m\",\n\t\tfid[\"input/sea_level\"][]*u\"m\",\n\t\tattrs[\"subsidence_rate\"][]*u\"m/Myr\")\nend\n\nfunction read_data(filename)\n\th5open(filename) do fid\n\t\theader = read_header(fid)\n\t\tdata = Data(\n\t\t\tfid[\"disintegration\"][]*u\"m\",\n\t\t\tfid[\"production\"][]*u\"m\",\n\t\t\tfid[\"deposition\"][]*u\"m\",\n\t\t\tfid[\"sediment_height\"][]*u\"m\")\n\t\theader, data\n\tend\nend\n\nfunction read_slice(filename, slice...)\n\th5open(filename) do fid\n\t\theader = read_header(fid)\n\t\tdata = DataSlice(\n\t\t\tfid[\"disintegration\"][slice...]*u\"m\",\n\t\t\tfid[\"production\"][slice...]*u\"m\",\n\t\t\tfid[\"deposition\"][slice...]*u\"m\",\n\t\t\tfid[\"sediment_height\"][slice[2:end]...]*u\"m\")\n\t\theader, data\n\tend\nend\n\nelevation(h::Header, d::Data) = let bl = h.bedrock_elevation[:,:,na],\n\t\t\t\t\t\t\t\t\tsr = h.axes.t[end] * h.subsidence_rate\n\tcat(bl, bl .+ d.sediment_elevation; dims=3) .- sr\nend\n\nelevation(h::Header, d::DataSlice, y) = let bl = h.bedrock_elevation[:,y,na],\n\t       \t\t\t\t\t\t\t\t sr = h.axes.t[end] * h.subsidence_rate\n\tcat(bl, bl .+ d.sediment_elevation; dims=2) .- sr\nend\n\ncolormax(d::Data) = getindex.(argmax(d.deposition; dims=1)[1,:,:,:], 1)\ncolormax(d::DataSlice) = getindex.(argmax(d.deposition; dims=1)[1,:,:], 1)\n\n\"\"\"\n    explode_quad_vertices(v)\n\nTakes a three dimensional array representing a grid of vertices. This function duplicates these\nvertices in the vertical direction, so that an amount of sediment can be given a single color.\n\nReturns a tuple of vertices and faces (triangles), suitable for plotting with Makie's `mesh`\nfunction.\n\"\"\"\nfunction explode_quad_vertices(v::Array{Float64, 3})\n\tw, h, d = size(v)\n\tpoints = zeros(Float64, w, h-1, 2, d)\n\tn_vertices = 2 * w * (h-1)\n\tn_quads = (w - 1) * (h - 1)\n\t@views points[:, :, 1, :] = v[1:end, 1:end-1, :]\n\t@views points[:, :, 2, :] = v[1:end, 2:end, :]\n\tidx = reshape(1:n_vertices, w, (h-1), 2)\n\tvtx1 = reshape(idx[1:end-1, :, 1], n_quads)\n\tvtx2 = reshape(idx[2:end, :, 1], n_quads)\n\tvtx3 = reshape(idx[2:end, :, 2], n_quads)\n\tvtx4 = reshape(idx[1:end-1, :, 2], n_quads)\n\treturn reshape(points, n_vertices, d),\n\t\tvcat(hcat(vtx1, vtx2, vtx3), hcat(vtx1, vtx3, vtx4))\nend\n\n\"\"\"\n    bean_counter(mask)\n\nGiven a mask (array of binary values), performs a floodfill on all connected components,\ngiving each an integer identifier.\n\nReturns the array of integers identifying each group and the number of groups.\n\"\"\"\nfunction bean_counter(mask::BitArray{dim}) where {dim}\n\tvisited = BitArray{dim}(undef, size(mask)...)\n\tvisited .= false\n\tout = zeros(Int, size(mask)...)\n\tdxs = CartesianIndices(ntuple(_->3, dim)) .|> (x -> x - CartesianIndex(ntuple(_->2, dim))) |> filter(x->x!=CartesianIndex(ntuple(_->0, dim)...))\n\tgroup = 1\n\n\tfor idx in CartesianIndices(mask)\n\t\tvisited[idx] && continue\n\t\tvisited[idx] = true\n\t\tmask[idx] || continue\n\t\tout[idx] = group\n\n\t\tstack = idx .+ dxs\n\t\twhile !isempty(stack)\n\t\t\tjdx = pop!(stack)\n\t\t\tcheckbounds(Bool, mask, jdx) || continue\n\t\t\tvisited[jdx] && continue\n\t\t\tvisited[jdx] = true\n\t\t\tmask[jdx] || continue\n\t\t\tout[jdx] = group\n\t\t\tappend!(stack, jdx .+ dxs)\n\t\tend\n\t\tgroup += 1\n\tend\n\treturn out, group-1\nend\n\nfunction sediment_profile!(ax::Axis, filename, y)\n    header, data = read_slice(filename, :, :, y, :)\n\tx = header.axes.x |> in_units_of(u\"km\")\n\tt = header.axes.t |> in_units_of(u\"Myr\")\n\tŒæ = elevation(header, data, y)  # |> in_units_of(u\"m\")\n\n\tverts = zeros(Float64, length(x), length(t), 2)\n\t@views verts[:, :, 1] .= x\n\t@views verts[:, :, 2] .= Œæ |> in_units_of(u\"m\")\n\tv, f = explode_quad_vertices(verts)\n\n\twater_depth = Œæ .- (header.subsidence_rate .* (header.axes.t .- header.axes.t[end]) .+ header.sea_level)[na, :]\n\tgaps, n_gaps = bean_counter(water_depth .> 0u\"m\")\n\n\tc = reshape(colormax(data)[:, :], length(x) * (length(t) - 1))\n\tmesh!(ax, v, f, color=vcat(c, c), alpha=1.0)\n\n\tfor g = 1:n_gaps\n\t\tsize = sum(gaps .== g)\n\t\tif size < 1000\n\t\t\tcontinue\n\t\tend\n\t\t# compute the mean z-value for a gap\n\t\tgap = mean.(skipmissing.(eachslice(CartesianIndices(Œæ) .|> (i -> gaps[i] == g ? Œæ[i] : missing), dims=(1,))))\n\t\tlines!(ax, x, gap |> in_units_of(u\"m\"), color=:white, linewidth=2, linestyle=:dash)\n\tend\nend\n\nfunction sediment_profile(filename, y)\n\tfig = Figure(size=(800,600))\n\tax = Axis(fig[1,1])\n\tsediment_profile!(ax, filename, y)\n\treturn fig\nend\n\nfunction plot_facies_production(input; loc = nothing)\n fig, loc = isnothing(loc) ? let fig = Figure(); (fig, fig[1, 1]) end : (nothing, loc)\n ax = Axis(loc, title=\"production at $(sprint(show, input.insolation; context=:fancy_exponent=>true))\", xlabel=\"production (m/Myr)\", ylabel=\"depth (m)\", yreversed=true)\n for f in input.facies\n  depth = (0.1:0.1:50.0)u\"m\"\n  prod = [production_rate(input.insolation, f, d) for d in depth]\n  lines!(ax, prod / u\"m/Myr\", depth / u\"m\")\n\n end\n fig\nend\n\nfunction plot_crosssection(pos, datafile)\n    # x: 1-d array with x-coordinates\n    # t: 1-d array with time-coordinates (n_steps + 1)\n    # h[x, t]: height fn, monotonic increasing in time\n    # p[x, facies, t]: production rate\n    # taken at y = y_max / 2, h[x, 1] is initial height\n    n_facies, x, t, h, p = h5open(datafile, \"r\") do fid\n        attr = HDF5.attributes(fid[\"input\"])\n        Œît = attr[\"delta_t\"][]\n        subsidence_rate = attr[\"subsidence_rate\"][]\n        t_end = fid[\"input/t\"][end-1]\n        total_subsidence = subsidence_rate * t_end\n        total_sediment = sum(fid[\"sediment\"][]; dims=3)\n        initial_height = fid[\"input/height\"][]\n        center = div(size(total_sediment)[1], 2)\n        elevation = cumsum(total_sediment; dims=4)[:, center, 1, :] .* Œît .- initial_height .- total_subsidence\n        t = fid[\"input/t\"][]\n        n_facies = size(fid[\"sediment\"])[3]\n\n        return n_facies,\n        fid[\"input/x\"][],\n        [t; Œît * attr[\"time_steps\"][]],\n        hcat(.-initial_height .- total_subsidence, elevation),\n        fid[\"sediment\"][:, center, :, :]\n    end\n\n    pts = vec(Point{2,Float64}.(x, h[:, 2:end]))\n    c = vec(argmax(p; dims=2)[:, 1, :] .|> (c -> c[2]))\n    rect = Rect2(0.0, 0.0, 1.0, 1.0)\n    m_tmp = GeometryBasics.mesh(Tesselation(rect, (100, 1000)))\n    m = GeometryBasics.Mesh(pts, faces(m_tmp))\n\n    # pts = vec(Point{2,Float64}.(x, h))\n    # c = argmax(p; dims=2)[:,1,:] .|> (c -> c[2])\n    # w = size(x)[1]\n\n    # face(idx) = let k = idx[1] + idx[2]*w\n    #     TriangleFace(k, k+1, k+1+w), TriangleFace(k+1+w, k+w, k)\n    # end\n\n    ax = Axis(pos, xlabel=\"location\", ylabel=\"depth\", limits=((-12, x[end]), nothing))\n    # for f in 1:n_facies\n    #     locs = CartesianIndices((size(x)[1], size(t)[1] - 1))[c .== f]\n    #     triangles = collect(Iterators.flatten(face.(locs)))\n    #     m = GeometryBasics.Mesh(pts, triangles)\n    #     mesh!(ax, m)\n    # end\n\n    mesh!(ax, m, color=c, alpha=0.7)\n    for idx in [1, 501, 1001]\n        lines!(ax, x, h[:, idx], color=:black)\n        text!(ax, -2.0, h[1, idx]; text=\"$(t[idx]) Myr\", align=(:right, :center))\n    end\n    for idx in [250, 750]\n        lines!(ax, x, h[:, idx], color=:black, linewidth=0.5)\n    end\nend\n\nend","category":"page"},{"location":"stencils/#Stencil-operations","page":"Stencils","title":"Stencil operations","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"A stencil is the common term for computing many-to-one operations on grids. Examples of applications are:","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Finite difference schemes\nFinite Impulse Response (FIR) filters\nConvolutions (encompassing the previous two)\nCellular Automata","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Note that for larger convolution kernels, it is often more efficient to perform convolutions in the Fourier domain. On the matter of performance: stencil operations are the textbook example for computations that perform really well on GPUs.","category":"page"},{"location":"stencils/#Implementation","page":"Stencils","title":"Implementation","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Using these helper functions we can now define a stencil operation. Given the boundary trait, a stencil size and a response function, we can transform an array to a next generation.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<div class=\"noweb-label\">‚™°stencil-operation‚™¢‚â£</div>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"function stencil(::Type{TIn}, ::Type{TOut}, ::Type{BT}, n::NTuple{dim,Int}, f::Function) where {TIn, TOut, dim, BT <: Boundary{dim}}\n    m = n .√∑ 2\n    stencil_shape = range.(.-m, m)\n    stencil = Array{TIn, dim}(undef, n...)\n\n    function(z_in::AbstractArray{TIn, dim}, z_out::AbstractArray{TOut, dim}, args...)\n        @assert (size(z_in) == size(z_out)) \"sizes of arrays need to be equal\"\n        shape = size(z_in)\n        for i in CartesianIndices(shape)\n            for (k, Œîi) in enumerate(CartesianIndices(stencil_shape))\n                stencil[k] = offset_value(BT, z_in, i, Œîi)\n            end\n            z_out[i] = f(stencil, args...)\n        end\n    end\nend\n\nstencil(::Type{T}, ::Type{BT}, n::NTuple{dim, Int}, f::Function) where {T, dim, BT <: Boundary{dim}} =\n    stencil(T, T, BT, n, f)\n\nconvolution(::Type{TIn}, ::Type{TOut}, ::Type{B}, kernel::AbstractArray{U, dim}) where { dim, TIn, TOut, U, B <: Boundary{dim} } =\n    stencil(TIn, TOut, B, size(kernel), s -> sum(s .* kernel))\n\nconvolution(::Type{B}, kernel::AbstractArray{T, dim}) where {dim, T, B <: Boundary{dim}} =\n    stencil(T, T, B, size(kernel), s -> sum(s .* kernel))","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"More efficient implementations are imaginable. For instance we could use normal unchecked indexing for most of the array, and only use the offset_value function when we really need it. Another optimisation could be to generate parts of the inner loop, and/or do the outer loop in parallel.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"We will now test this function first on an Elementary CA (ECA), Conway's Game of Life, and a convolution.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<details><summary>Stencil module</summary>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<div class=\"noweb-label\">file:<i>src/Stencil.jl</i></div>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"module Stencil\n\nusing ..Config: AbstractBox\nusing ..BoundaryTrait\n\nexport stencil, convolution\n\n<<stencil-operation>>\n\nend","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"</details>","category":"page"},{"location":"stencils/#Examples","page":"Stencils","title":"Examples","text":"","category":"section"},{"location":"stencils/#Elementary-Cellular-Automata","page":"Stencils","title":"Elementary Cellular Automata","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"An Elementary Cellular Automata is a one-dimensional CA with two states. Every next generation depends on the direct neighbourhood of three cells. Since there are 2^3 = 8 patterns and two outcomes for every pattern, there are 2^8 = 256 possible ECA.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<div class=\"noweb-label\">file:<i>examples/ca/eca.jl</i></div>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"#| creates: docs/src/_fig/eca.png\n#| requires: src/Stencil.jl\n#| collect: figures\n\nmodule ECA\n    using CarboKitten.BoundaryTrait\n    using CarboKitten.Stencil\n    using CairoMakie\n\n    rule(i::Int) = function (foo::AbstractVector{T}) where T <: Integer\n        d = foo[1]*4 + foo[2]*2 + foo[3]\n        i & (1 << d) == 0 ? 0 : 1\n    end\n\n    function eca(r::Int, n::Int, iter::Int)\n        y = Array{Int}(undef, n, iter)\n        y[:, 1] = zeros(Int, n)\n        y[div(n, 2), 1] = 1\n        stencil_op = stencil(Int, Periodic{1}, (3,), rule(r))\n        for i in 2:iter\n            stencil_op(view(y, :, i-1), view(y, :, i))\n        end\n        y\n    end\n\n    function plot()\n        fig = Figure(size=(1200,400))\n        for (idx, r) in enumerate([18, 30, 110])\n            ax = Axis(fig[1,idx]; title=\"rule $(r)\", yreversed=true, limits=((1, 256), (1, 128)))\n            heatmap!(ax, eca(r, 256, 128); colormap=:Blues)\n        end\n        save(\"docs/src/_fig/eca.png\", fig)\n    end\nend\n\nECA.plot()","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"(Image: )","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Even these one-dimensional CA show highly complex behaviour. For instance, it has been shown that rule 110 is Turing complete.","category":"page"},{"location":"stencils/#Game-of-Life","page":"Stencils","title":"Game of Life","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Perhaps the most famous CA is Conway's Game of Life. This is a two-dimensional two-state (dead/alive) CA, with the following rules: a cell is alive in the next generation if it is alive and has two neighbours or if it has three neighbours; in all other cases the cell is dead.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"<div class=\"noweb-label\">file:<i>examples/ca/life.jl</i></div>","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"#| creates: docs/src/_fig/life.gif\n#| requires: src/Stencil.jl\n#| collect: figures\n\nmodule Life\n    using CarboKitten.BoundaryTrait\n    using CarboKitten.Stencil\n    using GLMakie\n    using .Iterators: take\n\n    \"x is a 3x3 region around the cell at x[2,2].\"\n    rules(x) = let c = x[2, 2], s = sum(x) - c\n        c && s == 2 || s == 3\n    end\n\n    function game_of_life(w, h)\n        y1 = rand(Bool, (w, h))\n        y2 = Array{Bool}(undef, w, h)\n\n        op = stencil(Bool, Periodic{2}, (3, 3), rules)\n        Channel() do ch\n            put!(ch, y1)\n            while true\n                op(y1, y2)\n                (y1, y2) = (y2, y1)\n                put!(ch, y1)\n            end\n        end\n    end\n\n    function plot()\n        life = take(game_of_life(50, 50), 150)\n        fig = Figure()\n        ax = Axis(fig[1,1], aspect=1)\n        record(fig, \"docs/src/_fig/life.gif\", life; framerate=10) do frame\n            heatmap!(ax, frame; colormap=:Blues)\n        end\n    end\nend\n\nLife.plot()","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"(Image: )","category":"page"},{"location":"stencils/#Testing-boundaries-with-a-convolution","page":"Stencils","title":"Testing boundaries with a convolution","text":"","category":"section"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"To test the different boundary types, lets try the following setup. We take a 16x16 image with all zeros except the bottom left gets a value of 1 and the top right pixel gets a value of 2. Now convolve with a Gaussian and see what happens. For the constant boundary, I've set the value to 0.1, to see the effect.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"(Image: )","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"Notice, that for the periodic boundaries, the bottom left and top right are neighbouring. So there the two pixels appear as a single peak. In the reflected case we see a clear distinction between the two corners.","category":"page"},{"location":"stencils/","page":"Stencils","title":"Stencils","text":"#| creates: docs/src/_fig/boundary_types.png\n#| requires: src/Stencil.jl\n#| collect: figures\n\nmodule Script\n\nusing CarboKitten.BoundaryTrait\nusing CarboKitten.Stencil\nusing CairoMakie\n\nfunction plot_boundary_types()\n    n = 16\n    y0 = zeros(Float64, n, n)\n    y0[1, 1] = 1\n    y0[n, n] = 2\n    x = collect(-2:0.25:2)\n    k = exp.(-(x.^2 .+ x'.^2))\n    k ./= sum(k)\n\n    y_periodic = Array{Float64}(undef, n, n)\n    convolution(Periodic{2}, k)(y0, y_periodic)\n    y_reflected = Array{Float64}(undef, n, n)\n    convolution(Reflected{2}, k)(y0, y_reflected)\n    y_constant = Array{Float64}(undef, n, n)\n    convolution(Constant{2, 0.1}, k)(y0, y_constant)\n\n    fig = Figure(size=(900, 300))\n    for (i, y) in enumerate([y_periodic, y_reflected, y_constant])\n        ax = Axis(fig[1,i]; aspect=1)\n        heatmap!(ax, y; colormap=:viridis)\n    end\n    save(\"docs/src/_fig/boundary_types.png\", fig)\nend\nend \n\nScript.plot_boundary_types()","category":"page"},{"location":"sediment-buffer/#Sediment-Buffers","page":"Sediment Buffers","title":"Sediment Buffers","text":"","category":"section"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"FIXME: Needs some graphics to explain concepts","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"In some models of transport it is important to remember the type of sediment facies some time in the past. Suppose sedimented material is loosened again due to submarine erosion processes. Particle sizes may depend on the sediment facies.","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"To compute such models efficiently we need to store the sedimentation history in a buffer. One approach is to remember several iterations into the past, but then there will be areas where sedimentation is slow and fast, and soon you'll find you have to store the entire simulation for retrieval.","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"The proposed data structure is one that stores the history discretized in depth. We loose a bit of precision on the thinnest sedimentation layers, but we can freely mix older and younger sediments when needed.","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"There are several choices on how to structure the sediment buffer. We can grow sediment from the bottom of the buffer, but that requires keeping an array of pointers to the bottom depth where new material is deposited.","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"Another choice is to keep the sea floor in the same layer of the buffer, and copy down sediment when a layer is full. We may need to implement both to see which is more efficient.","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"We define two functions push_sediment! and pop_sediment!. Given a s times n matrix, where n is the number of facies types and s is the depth of the stack, we can grow and shrink sediment. These functions are unit-free, setting Delta z to be equal to 1.","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"<div class=\"noweb-label\">file:<i>test/SedimentStackSpec.jl</i></div>","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"@testset \"SedimentStack\" begin\n  using CarboKitten.SedimentStack: push_sediment!, pop_sediment!\n  stack = zeros(Float64, 10, 3)\n  @test pop_sediment!(stack, 0.0) == [0.0, 0.0, 0.0]\n  push_sediment!(stack, [5.0, 0, 0])\n  @test pop_sediment!(stack, 1.5) == [1.5, 0.0, 0.0]\n  push_sediment!(stack, [0.0, 2.0, 0.0])   # (0 0.5) (0 1) (0.5 0.5) (1 0) ...\n  @test pop_sediment!(stack, 2.0) == [0.25, 1.75, 0.0]\n  @test pop_sediment!(stack, 1.5) == [1.25, 0.25, 0.0]\n  @test pop_sediment!(stack, 0.0) == [0.0, 0.0, 0.0]\nend\n\n@testset \"SedimentArray\" begin\n  using CarboKitten.SedimentStack: push_sediment!, peek_sediment\n  sediment = zeros(Float64, 10, 3, 5, 5)\n  for x in 1:10\n    production = rand(3, 5, 5)\n    push_sediment!(sediment, production)\n  end\n  a = peek_sediment(sediment, 1.0)\n  @test all(sum(a; dims=1) .‚âà 1.0)\nend","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"<details><summary>SedimentStack impl</summary>","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"<div class=\"noweb-label\">file:<i>src/SedimentStack.jl</i></div>","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"module SedimentStack\n\nexport push_sediment!, pop_sediment!, peek_sediment\n\nfunction push_sediment!(col::AbstractMatrix{F}, parcel::AbstractVector{F}) where F <: Real\n  Œî = sum(parcel)\n  bucket = sum(col[1, :])\n\n  if bucket + Œî < 1.0\n    col[1,:] .+= parcel\n    return\n  end\n\n  frac = parcel ./ Œî\n  col[1,:] .+= frac .* (1.0 - bucket)\n  Œî -= (1.0 - bucket)\n  n = floor(Int64, Œî)\n\n  col[n+2:end,:] = col[1:end-n-1,:]\n  na = [CartesianIndex()]\n  col[2:n+1,:] .= frac[na,:]\n  Œî -= n\n\n  col[1,:] .= frac .* Œî\nend\n\nfunction push_sediment!(sediment::AbstractArray{F, 4}, p::AbstractArray{F, 3}) where F <: Real\n  _, x, y = size(p)\n  @views for i in CartesianIndices((x, y))\n    push_sediment!(sediment[:, :, i[1], i[2]], p[:, i[1], i[2]])\n  end\nend\n\n@inline function pop_fraction(col::AbstractMatrix{F}, Œî::F) where F <: Real\n  bucket = sum(col[1,:])\n  if Œî == 0 || bucket == 0\n    return zeros(F, size(col)[2])\n  end\n\n  @assert Œî < bucket \"pop_fraction can only pop from the top cell: $(col), $(Œî)\"\n  parcel = (Œî / bucket) .* col[1,:]\n  col[1,:] .-= parcel\n  return parcel\nend\n\nfunction peek_sediment(col::AbstractMatrix{F}, Œî::F) where F <: Real  # -> Vector{F}\n  if Œî == 0\n      return zeros(F, size(col)[2])\n  end\n\n  bucket = sum(col[1,:])\n  if Œî < bucket\n    parcel = (Œî / bucket) .* col[1,:]\n    return parcel\n  end\n\n  parcel = copy(col[1,:])\n  Œî -= bucket\n  n = floor(Int64, Œî)\n\n  parcel .+= sum(col[2:n+1,:]; dims=1)'\n  Œî -= n\n\n  last_bit = (Œî / sum(col[n+2,:])) .* col[n+2,:]\n  parcel .+= last_bit\n\n  return parcel\nend\n\nfunction peek_sediment(sediment::AbstractArray{F,4}, Œî::F) where F <: Real\n  _, f, x, y = size(sediment)\n  out = Array{F, 3}(undef, f, x, y)\n  for i in CartesianIndices((x, y))\n    out[:, i[1], i[2]] = peek_sediment(@view(sediment[:, :, i[1], i[2]]), Œî)\n  end\n  return out\nend\n\nfunction pop_sediment!(col::AbstractMatrix{F}, Œî::F) where F <: Real  # -> Vector{F}\n  bucket = sum(col[1,:])\n  if Œî < bucket\n    return pop_fraction(col, Œî)\n  end\n\n  parcel = copy(col[1,:])\n  Œî -= bucket\n  n = floor(Int64, Œî)\n\n  parcel .+= sum(col[2:n+1,:]; dims=1)'\n  col[1:end-n-1, :] = col[n+2:end, :]\n  col[end-n-1:end, :] .= 0\n  Œî -= n\n\n  parcel .+= pop_fraction(col, Œî)\n  return parcel\nend\n\nfunction pop_sediment!(cols::AbstractArray{F, 4}, amount::AbstractArray{F, 2}, out::AbstractArray{F, 3}) where F <: Real\n  @views for i in CartesianIndices(amount)\n      out[:, i[1], i[2]] = pop_sediment!(cols[:, :, i[1], i[2]], amount[i[1], i[2]])\n  end\nend\n\nend # module","category":"page"},{"location":"sediment-buffer/","page":"Sediment Buffers","title":"Sediment Buffers","text":"</details>","category":"page"},{"location":"#CarboKitten.jl:-Modeling-Carbonate-Platforms-in-Julia","page":"Introduction","title":"CarboKitten.jl: Modeling Carbonate Platforms in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Entangled badge)","category":"page"},{"location":"#About","page":"Introduction","title":"About","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CarboKitten is a reimplementation of Peter Burgess' CarboCAT, a model for generating carbonate platform stratigraphies. CarboKitten is a three-dimensional model, having two spatial dimensions and one for stored stediment.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Cellular Automata to regulate facies type\nAdvection-diffusion based sediment transport","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Sample output stratigraphy)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CarboKitten is written in Julia for performance and extensibility.","category":"page"},{"location":"#Julia-Quickstarter","page":"Introduction","title":"Julia Quickstarter","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This code is written in Julia. You may want to check out the following references:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia Documentation\nTutorial on Julia for Science and Engineering","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are several ways to work with Julia that may be a bit different from what you're used to, if that is Matlab, Python or R.","category":"page"},{"location":"#Installing-Julia","page":"Introduction","title":"Installing Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The best way to install Julia is to use juliaup at github.com/JuliaLang/juliaup.","category":"page"},{"location":"#REPL","page":"Introduction","title":"REPL","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The most basic way to work in Julia, is to start the REPL (Read Eval Print Loop).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.3 (2023-08-24)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"From here you may use CarboKitten using CarboKitten and run any of the code inside. To work with CarboKitten efficiently, you may want to load Revise. Revise auto-detects changes to loaded code and makes it easy to rerun.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Additionally you should learn how to work with Julia packages. If you want to experiment with things, try to create a new environment in an empty folder and add CarboKitten as a dev dependency:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> dev <path to CarboKitten>","category":"page"},{"location":"#VS-Code","page":"Introduction","title":"VS Code","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"VSCode has very good support for working with Julia. Install the official Julia plugin and you should be good to go. Explore options by pressing Ctrl+Shift+P and type Julia to see what you can do. For example: start a REPL, run current script etc.","category":"page"},{"location":"#Jupyter","page":"Introduction","title":"Jupyter","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"You can run Julia code from Jupyter if you install the Julia kernel. Press ] in the REPL to get into Pkg-mode, the prompt will change","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(CarboKitten) pkg>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You may install the IJulia kernel with add IJulia.","category":"page"},{"location":"#Pluto","page":"Introduction","title":"Pluto","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An alternative (and in our opinion superior) notebook interface is called Pluto.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pluto is reactive: changes to code cells automatically update downstream dependencies.\nPluto notebooks are written to regular Julia files and can (though maybe shouldn't) be run independent from Pluto.\nThe user interface of Pluto is slightly less mature than Jupyter","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In Pkg-mode say add Pluto.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pluto\n\njulia> Pluto.run()\n[ Info: Loading...\n‚îå Info:\n‚îî Opening http://localhost:1234/?secret=xyzxyzzy in your default browser... ~ have fun!\n‚îå Info:\n‚îÇ Press Ctrl+C in this terminal to stop Pluto\n‚îî","category":"page"},{"location":"#Plotting","page":"Introduction","title":"Plotting","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The most used library to do plotting in Julia is called Plots.jl. However, this library comes with a fair share of problems: there are a number of back-ends for which the generated plots may look slightly different. Here \"back-end\" means some plotting library written in a different language than Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A nicer plotting library that also happens to be a bit more versatile is Makie.jl. This has three back-ends that are CairoMakie, GLMakie and WGLMakie. These are all written in Julia, but they focus on different kinds of results. CairoMakie is relatively slow but results in publication quality vector graphics: SVG or PDF. GLMakie is very fast, renders on your graphics card, but only produces raster images, say PNG. Then WGLMakie does a similar thing, but through the web-browser.","category":"page"},{"location":"#Design-style","page":"Introduction","title":"Design style","text":"","category":"section"},{"location":"#Input-structures","page":"Introduction","title":"Input structures","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Input datastructures are always @kwdef. This makes it easier to understand and modify simulation scripts.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Different components of CarboKitten can work a variety of input types, as long as their expected data members are present. TODO: systematically document type requirements for each component.","category":"page"},{"location":"#Output-data","page":"Introduction","title":"Output data","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"All output is written to HDF5 files.","category":"page"},{"location":"#Partial-functions","page":"Introduction","title":"Partial functions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Most of the model code is written in the following particular pattern:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function component(input)\n    prepare(input)\n\n    return function(state)\n        iterate!(state)\n    end\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this case the prepare() statement is run once at the beginning of a model run, while the iterate!(state) statement, possibly modifying the state variable, is being run every iteration.","category":"page"},{"location":"#Entangled","page":"Introduction","title":"Entangled","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you plan to make a contribution to the core of CarboKitten, you should be aware of Entangled.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation for CarboKitten is using Entangled for Literate Programming. This means that code blocks in the documentation contribute to the actual functioning code in the library. When you develop the library code, you should have the Entangled daemon running to keep the documentation synchronized. Included in the CarboKitten repository is a pyproject.toml that manages the Entangled installation for you through Poetry; alternatively, you may install Entangled through pip install entangled-cli.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To install, run poetry install in the project root, then:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"poetry run entangled watch","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Entangled is still under development and it may occur that the daemon complains about not knowing wether to tangle or stitch, for example when you've accidentally written both markdown and source code. If this happens you may manually entangled tangle or entangled stitch with the --force argument to decide the issue. It may be worth saving your work in version control before doing so.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A somewhat frequent occurence is that you forgot to run entangled watch while developing. In this case, commit the work you have done to git, then run entangled tangle or entangled stitch (whichever applies). Your files are now back in their old state, but you can git restore the edits you have made and run entangled sync again to propagate the changes. The project should be in a good state again.","category":"page"},{"location":"#Building-Documentation","page":"Introduction","title":"Building Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To recreate the plots in the documentation run","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"poetry run brei figures","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation can be rendered with Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia --workenv=docs docs/make.jl","category":"page"},{"location":"#Project-structure","page":"Introduction","title":"Project structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":".\n‚îú‚îÄ‚îÄ data                # data files\n‚îú‚îÄ‚îÄ docs                # documentation\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ make.jl         # docs build script\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Manifest.toml   #\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Project.toml    # dependencies for building docs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ src             # markdown source for docs\n‚îú‚îÄ‚îÄ entangled.toml      # entangled config\n‚îú‚îÄ‚îÄ examples            # example scripts\n‚îú‚îÄ‚îÄ Makefile            # command-line short hands\n‚îú‚îÄ‚îÄ Manifest.toml       #\n‚îú‚îÄ‚îÄ Project.toml        # project dependencies\n‚îú‚îÄ‚îÄ pyproject.toml      # dependencies for running Entangled\n‚îú‚îÄ‚îÄ README.md           #\n‚îú‚îÄ‚îÄ src                 # tangled library source\n‚îî‚îÄ‚îÄ test                # unit tests","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The figures from the documentation in \"docs/src/fig\" are git tracked, but are often regenerated when you change some of their direct dependencies. This makes switching branches harder, it would require issuing \"git stash\" first. We have made sure that the regenerated figures appear in docs/src/_fig and are not git tracked. There is a task in pyproject.toml that takes care of copying from docs/src/_fig to docs/src/fig when this repo is cloned:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"poetry run brei copy_figures","category":"page"},{"location":"#Authors","page":"Introduction","title":"Authors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Lead engineer: Johan Hidding Netherlands eScience Center email: j.hidding [at] esciencecenter.nl Web page: www.esciencecenter.nl/team/johan-hidding-msc/ ORCID: 0000-0002-7550-1796","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Original author: Peter Burgess University of Liverpool Web page: www.liverpool.ac.uk/environmental-sciences/staff/peter-burgess","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Project lead: Emilia Jarochowska Utrecht University email: e.b.jarochowska [at] uu.nl Web page: www.uu.nl/staff/EBJarochowska ORCID: 0000-0001-8937-9405","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Other team members:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Niklas Hohmann Utrecht University email: n.h.hohmann [at] uu.nl Web page: www.uu.nl/staff/NHohmann ORCID: 0000-0003-1559-1838","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Xianyi Liu Utrecht University email: x.liu6 [at] uu.nl Web page: www.uu.nl/staff/XLiu6 ORCID:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Hanno Spreeuw Netherlands eScience Center email: h.spreeuw [at] esciencecenter.nl Web page: www.esciencecenter.nl/team/dr-hanno-spreeuw/ ORCID: 0000-0002-5057-0322","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"David De Vleeschouwer Westf√§lische Wilhelms-Universit√§t M√ºnster Web page: www.uni-muenster.de/GeoPalaeontologie/erdsystemforschung/staff/DeVleeschouwer ORCID: 0000-0002-3323-807X","category":"page"},{"location":"#Copyright","page":"Introduction","title":"Copyright","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Copyright 2023 Netherlands eScience Center and Utrecht University","category":"page"},{"location":"#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.","category":"page"},{"location":"#Funding-information","page":"Introduction","title":"Funding information","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Funded by the European Union (ERC, MindTheGap, StG project no 101041077). Views and opinions expressed are however those of the author(s) only and do not necessarily reflect those of the European Union or the European Research Council. Neither the European Union nor the granting authority can be held responsible for them.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
